###### Event Streaming
Если **Event-Driven Architecture (EDA)** — это архитектурный стиль проектирования системы, то **Event Streaming** — это технологический механизм, лежащий в его основе.
Event Streaming отвечает за **непрерывную обработку, хранение и передачу событий в реальном времени**.
Если EDA — это про _что делать_ (реагировать на события), то Event Streaming — про _как это делать_ на практике:
- Как физически передаются события между сервисами
- Как они хранятся (например, в логах или очередях)
- Как обрабатываются и воспроизводятся для новых потребителей
Чаще всего Event Streaming реализуется с помощью специализированных платформ — таких как **Apache Kafka**.

###### Apache Kafka
Apache Kafka — не просто платформа потоковой обработки событий, это целая экосистема технологий, предназначенная для создания полноценных событийно-ориентированных систем.
![[pub_sub.png]]

###### Log aggregation
![[log_aggregation.png]]

###### Log shipping
![[log_shipping.png]]

###### SEDA pipelines
SEDA (Staged Event-Driven Architecture) — это расширение концепции событийно-ориентированной архитектуры (EDA), разработанное для масштабируемых, высоконагруженных и управляемых систем.
Вместо единого монолитного обработчика событий, SEDA разбивает обработку на последовательность независимых стадий (stages), каждая из которых:
- изолирована друг от друга,
- имеет собственную очередь событий,
- может масштабироваться и настраиваться отдельно.
Каждая стадия выполняет **ограниченный набор действий**, после чего передаёт событие на следующую стадию через очередь. Такой подход позволяет гибко управлять состояниями, нагрузкой и отказоустойчивостью.
![[SEDA_pipelines.png]]

###### Complex Event Processing
**Complex Event Processing (CEP)** — это подход к **выявлению значимых событий и паттернов** в потоке простых, низкоуровневых событий в реальном времени.
CEP не просто реагирует на отдельные события, как традиционный Event-Driven подход, а **анализирует их последовательности, временные зависимости и взаимосвязи**, чтобы извлекать более высокоуровневые, "композитные" события.
![[complex_event_processing.png]]

###### Event-Sourced CQRS
Event-Sourced CQRS (Command-Query Responsibility Segregation)
**Команды (commands)** — изменяют состояние системы.
**Запросы (queries)** — только читают данные.
![[event_sourced_CQRS.png]]

###### Kafka Architecture Overview
**ZooKeeper** — это отдельное программное обеспечение, которое используется Kafka для координации и управления кластером брокеров.
**Kafka Broker** — это посредник между produces и consumer
**Kafka Cluster** — это набор брокеров, объединённых и синхронизированных друг с другом.
![[Kafka_Architecture_Overview.png]]

###### Total, partial and casual order
**Total Order**  
Строгий глобальный порядок, при котором любая пара элементов может быть сравнена между собой, и для них однозначно определено, какое из событий произошло раньше.

**Partial Order**  
Порядок, при котором элементы можно сравнивать только внутри отдельных групп, но не между всеми парами.  

**Causal Order**
Порядок, который сохраняет причинно-следственные зависимости между событиями.  
Если событие A стало причиной события B, то A должно быть обработано до B.  
Это не обязательно хронологический порядок — важна именно логическая связь.  
Пример: пользователь сначала добавил товар в корзину, а потом оформил заказ — система должна обработать эти действия в причинном порядке, даже если они пришли в разное время.

###### Records
**Record** is the most elemental unit of persistence in Kafka. In the context of event-driven architecture, which is chiefly how one is meant to use Kafka, a record typically corresponds to some event of interest.

**Key:** Запись может быть связана с необязательным неуникальным ключом, который служит своего рода классификатором — группируя связанные записи на основе их ключей. Ключ является полностью произвольным: всё, что может быть представлено в виде массива байтов, может служить ключом записи.

**Value:** Значение — это, по сути, информационная нагрузка записи. В деловом контексте это самая важная часть записи, поскольку именно значение описывает событие. Значение является необязательным, хотя редко встречаются записи с `null`-значением. Без значения запись в основном бесполезна; все остальные атрибуты лишь помогают передать значение.

**Headers:** Набор произвольных пар ключ-значение, которые могут быть использованы для дополнительной аннотации записи. Заголовки в Kafka аналогичны заголовкам в HTTP — они дополняют основную нагрузку дополнительными метаданными.

**Partition number:** Индекс (с нуля) раздела, в котором находится запись. Запись всегда должна быть привязана ровно к одному разделу; однако сам раздел может не указываться явно при публикации записи.

**Offset:** 64-битное знаковое целое число, определяющее местоположение записи в её разделе. Записи хранятся последовательно; смещение представляет логический номер последовательности записи.

**Timestamp:** Метка времени с миллисекундной точностью. Она может быть задана явно продюсером до отправки или автоматически назначена брокером в момент, когда запись добавляется в лог.

###### Partitions
**Partition** — это полностью упорядоченный, неограниченный набор записей. Опубликованные записи добавляются в конец (head-end) соответствующей партиции. Partition — это элементарная единица потока записей.
Records, публикуемые одним и тем же producer в одну partition, имеют причинно-следственный порядок (causal order). При этом причинно-следственный порядок между разными producers не гарантируется. Если два (или более) producers одновременно публикуют records в одну и ту же partition, эти records могут оказаться в произвольном порядке.
Итоговый порядок будет зависеть не от того, какой producer попытался опубликовать record первым, а от того, чья record первой достигла лидера партиции.
Следствием этого является то, что в отсутствие синхронизации между продюсерами, причинно-следственный порядок можно гарантировать только в одном случае — когда один продюсер публикует записи в одну и ту же партицию.

**Offset** записи уникально идентифицирует её внутри партиции. Смещение играет роль первичного ключа, что позволяет выполнять быстрый поиск за O(1).
Offset — это строго монотонно возрастающее целое число в разреженном адресном пространстве. Это означает, что каждое последующее смещение всегда больше предыдущего, однако между соседними значениями могут быть разрывы.

**Beginning offset** — это первая запись, которая будет представлена потенциальному консьюмеру.  
Из-за ограниченного срока хранения в Kafka это не обязательно первая опубликованная запись.  
Записи могут быть удалены на основании времени хранения и/или размера партиции.
Когда это происходит, нижняя граница сдвигается вперёд, и все записи до неё считаются удалёнными.

**End offset** — это смещение, следующее за последней успешно реплицированной записью.
![[partition.png]]

###### Topic
A topic is a logical aggregation of partitions.
![[Topic.png]]
