---
tags:
  - review
sr-due: 2026-02-15
sr-interval: 20
sr-ease: 230
---

---
**Isolation** определяет, как транзакции могут взаимодействовать между собой, и насколько сильно могут пересекаться и мешать друг другу при параллельной работе. Иначе говоря, разные уровни изоляции допускают или не допускают разные аномалии при параллельной работе транзакций.

Всего есть 4 основных уровня изоляции:
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

###### **READ UNCOMMITTED**
Это самый слабый уровень изоляции, когда транзакция может видеть результаты других транзакций, даже если они ещё не закоммичены.

Например, моя транзакция делает SELECT баланса из аккаунта 1, а вторая транзакция параллельно меняет этот баланс, но не коммитит изменения. Даже без коммита второй транзакции мой селект вернёт новый изменённый баланс. А если вторая транзакция откатит изменения и я опять сделаю SELECT к балансу, то я получу уже старый баланс. Это как раз аномалия, которая называется «грязное чтение» (Dirty Read) — когда данные, которые я прочитал, кто-то может откатить ещё до того, как я завершу свою транзакцию.

Причём в этой ситуации моя первая транзакция прочитает баланс, и она явно как-то будет его использовать дальше в своей логике, а параллельно вторая транзакция, несмотря на это, сможет изменить баланс — получается, что я в своей транзакции использовал уже неактуальные данные — это аномалия «неповторяющееся чтение» (Non‑repeatable Read) — когда данные, которые я прочитал, кто‑то может изменить ещё до того, как я завершу свою транзакцию. А называется эта аномалия так, потому что я могу дважды прочитать одни и те же строки в одной транзакции в разное время и получить разный результат, потому что кто-то параллельно изменил данные.

Ну и в-третьих,может быть ситуация, когда я своей первой транзакции прочитал какие‑то строки из БД (например, выбрал все аккаунты с балансом = 0), а вторая транзакция параллельно добавила новый аккаунт, у которого нулевой баланс — получается, моя первая транзакция думает, что аккаунтов с нулевым балансом у нас, например, 10, а по факту их будет уже 11. Это аномалия «фантомное чтение» (Phantom Read) — когда ряд данных, которые я прочитал, кто‑то может изменить до того, как я завершу свою транзакцию.

###### **READ COMMITTED**
На этом уровне транзакция может читать только те изменения в других параллельных транзакциях, которые уже были закоммичены. Это нас спасает от грязного чтения, но не спасает от неповторяющегося чтения и от фантомного чтения. Конечно, я теперь могу в своей транзакции прочитать баланс аккаунта, только который уже закоммичен, но ведь может возникнуть ситуация, когда параллельно другая транзакция меняет уже прочитанные мной данные и сразу коммитит, а моя транзакция всё ещё работает — получается, в своей транзакции я всё расчитываю исходя из одних данных (например, что баланс = 100), но пока моя транзакция выполнялась, баланс уже стал = 200.

От фантомного чтения этот уровень тоже не защищает ровно по тем же причинам - мы два раза в транзакции делаем один и тот же SELECT, но получаем в них разные результаты, потому что кто-то между моими селектами изменил набор нужных мне строк.

###### **REPEATABLE READ**
Этот уровень означает, что пока транзакция не завершится, никто параллельно не может изменять или удалять строки, которые транзакция уже прочитала. Т. е. данные, которые я прочитал своей транзакцией, точно никто не изменит, пока я не завершу свою транзакцию (по крайней мере, в классическом понимании этого уровня с блокировками).

Это нас спасает и от грязного чтения, и от неповторяющегося чтения, но всё ещё мы не решаем проблему фантомного чтения. Почему? Конечно, строки, которые я уже прочитал в транзакции, никто не изменит, но никто не мешает добавлять новые строки параллельно - их мы ещё не читали, создавать их ничего не мешает.

###### **SERIALIZABLE**
Самый жёсткий, но самый тяжёлый для БД и медленный для обработки запросов уровень. Он блокирует любые действия, пока запущена транзакция — получается, транзакции идут строго одна за другой и максимально изолируются друг от друга. Это достигается с помощью блокировки всей таблицы от любых взаимодействий с ней, но некоторые СУБД делают менее радикально — блокируют только те строки, которые задействует текущая транзакция.

Тут никакие аномалии нам не страшны — ни грязное, ни неповторяемое, ни фантомное чтение. Но и производительность тут страдает, ведь транзакции не могут работать параллельно.