**SS-table (Sorted String Table)** — это неизменяемая (immutable) отсортированная структура данных на диске, в которой хранятся пары `ключ → значение`, отсортированные по ключу. 

**LSM (Log-Structured Merge Tree)** — это структура хранения, оптимизированная для высокой скорости записи, использующая:
- память (in-memory MemTable) для быстрой записи
- диск (SS-таблицы) для долговременного хранения,
- периодическую компактацию для упорядочивания и слияния.

###### **Мотивация**
Традиционные B-деревья (как в PostgreSQL) хорошо читают, но дороги при частых вставках/обновлениях, особенно на диске.
LSM-деревья наоборот:
- Очень быстро пишут (в память и журнал).
- Запись — аппендиксная (добавление в конец).
- Чтения чуть медленнее (но решается кэшами и фильтрами).
    
###### **Как работает LSM-дерево (пошагово)**
##### 1. `write() → MemTable (in-memory)`
Новая пара `ключ → значение` записывается:
- в MemTable (обычно `SkipList` или `Red-Black Tree`),
- и в WAL (write-ahead log) — журнал на диске, чтобы не потерять данные при краше.
    

###### 2. `flush() → SSTable на диск`
Когда MemTable переполнена → она сбрасывается на диск в виде новой SS-таблицы (Level 0).
Эти таблицы неизменяемы, каждая flush — новый файл.

###### 3. `compaction()`
Со временем накапливаются десятки SS-таблиц. LSM делает слияние:
- сливает пересекающиеся диапазоны ключей,
- удаляет устаревшие/перезаписанные значения, 
- сохраняет новую компактную SSTable.

###### 4. `read(key)`
Для чтения:
1. Сначала ищется в MemTable
2. Потом в immutable MemTable (на стадии flush)
3. Потом по уровням SSTable (в порядке от свежего к старому)   
    - используются Bloom-фильтры и индексы для пропуска ненужных таблиц
