Хуки — это специальные функции, доступные только во время рендера React. Они позволяют «подключаться» к различным возможностям React.

Хуки (функции, начинающиеся с `use`) можно вызывать только на верхнем уровне ваших компонентов или собственных хуков. Нельзя вызывать хуки внутри условий, циклов или других вложенных функций.

###### **State Hooks**
[[1 State]]
[useState](https://react.dev/reference/react/useState)
Состояние позволяет компоненту «запоминать» информацию, например, ввод пользователя.
Чтобы добавить состояние в компонент, используйте один из этих хуков:
- `useState` — объявляет переменную состояния, которую можно обновлять напрямую.
- `useReducer` — объявляет переменную состояния, где логика обновления описана внутри функции-редьюсера.

###### **Context Hooks**
[useContext](https://react.dev/reference/react/useContext)
Контекст позволяет компоненту получать данные от дальних родительских компонентов без передачи их через пропсы.  
Например, корневой компонент вашего приложения может передавать текущую тему интерфейса всем вложенным компонентам, независимо от уровня вложенности.
`useContext` — считывает и подписывается на контекст.
```jsx
function Button() {
  const theme = useContext(ThemeContext);
  // ...
}
```

###### **Ref Hooks**
[useRef](https://react.dev/reference/react/useRef)
Refs позволяют компоненту хранить информацию, которая не используется для рендеринга, например DOM-узел или идентификатор таймера.
В отличие от состояния, обновление ref не вызывает повторный рендер вашего компонента.
- `useRef` — объявляет ref. В нём можно хранить любое значение, но чаще всего ref используется для хранения DOM-узла.
- `useImperativeHandle` — позволяет настраивать ref, который ваш компонент передаёт наружу.
```jsx
function Form() {
  const inputRef = useRef(null);
  // ...
}
```

###### **Effect Hooks**
Эффекты позволяют компоненту подключаться и синхронизироваться с внешними системами.  
Сюда относятся работа с сетью, браузерным DOM, анимациями, виджетами, написанными с использованием других UI-библиотек, и другим кодом вне React.
- `useEffect` — подключает компонент к внешней системе.
```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
}
```

###### **Performance Hooks**
Распространённый способ оптимизации производительности при повторных рендерах — это пропуск ненужной работы.  
Например, вы можете сказать React повторно использовать закэшированный результат вычисления или пропустить повторный рендер, если данные не изменились с предыдущего раза.

Чтобы избежать лишних вычислений и повторных рендеров, используйте один из этих хуков:
- `useMemo` — позволяет кэшировать результат «дорогого» вычисления.
- `useCallback` — позволяет кэшировать определение функции перед передачей её в оптимизированный компонент.
```jsx
function TodoList({ todos, tab, theme }) {
  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
  // ...
}
```