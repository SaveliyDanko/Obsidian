---
tags:
  - review
sr-due: 2026-07-08
sr-interval: 166
sr-ease: 270
---

---
[State](https://react.dev/learn/state-a-components-memory)
[React hooks not magic just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

---
###### **State в React**
- State — это встроенный объект в компоненте, который хранит динамические данные.
- Изменение state вызывает перерендер компонента.

---
###### **State vs local variable**
Почему изменение локальной переменной не влияет на страницу:
- Локальные переменные не сохраняются между рендерами. Когда React рендерит компонент во второй раз, он делает это с нуля — изменения локальных переменных не учитываются.
- Изменения локальных переменных не вызывают повторный рендер. React не понимает, что нужно снова отрендерить компонент с новыми данными.

Чтобы обновить компонент с новыми данными, нужно выполнить два условия:
- Сохранить данные между рендерами.
- Сообщить React, что компонент нужно перерендерить с новыми данными.

Хук **useState** предоставляет обе возможности:
- Переменную состояния для сохранения данных между рендерами.
- Функцию-сеттер для обновления переменной и вызова повторного рендера компонента.

---
###### **useState**
Чтобы добавить переменную состояния, импортируйте `useState` из React в начале файла:
```js
import { useState } from 'react';

const [index, setIndex] = useState(0);
```
`index` — это переменная состояния, а `setIndex` — функция-сеттер.

Вот как они работают вместе в `handleClick`:
```js
function handleClick() {
	setIndex(index + 1);
}
```
Существует соглашение об именовании такой пары в виде `const [something, setSomething]`. Вы можете назвать её как угодно, но использование соглашений облегчает понимание кода в разных проектах.

---
###### **Anatomy of useState**
Когда вы вызываете `useState`, вы говорите React, что хотите, чтобы этот компонент что-то запомнил:
```js
const [index, setIndex] = useState(0);
```
В данном случае вы хотите, чтобы React запомнил `index`.

Единственный аргумент `useState` — это начальное значение переменной состояния. В этом примере начальное значение `index` задаётся как `0`.

Каждый раз при рендере компонента `useState` возвращает массив из двух элементов:
1. Переменная состояния (`index`) — текущее сохранённое значение.
2. Функция-сеттер (`setIndex`) — обновляет переменную состояния и заставляет React перерендерить компонент.

---
###### **Как это работает пошагово**
```js
const [index, setIndex] = useState(0);
```
1. Первый рендер:  
    - Вы передали `0` в `useState`, значит React вернёт `[0, setIndex]`.  
    - React «запоминает», что текущее значение `index = 0`.
    
2. Обновление состояния:  
    - Пользователь кликает кнопку $\rightarrow$ вызывается `setIndex(index + 1)`.  
    - Так как `index = 0`, вызывается `setIndex(1)`.  
    - React сохраняет новое значение `index = 1` и запускает повторный рендер.
    
3. Второй рендер:  
    - React снова видит `useState(0)`, но помнит, что `index` был обновлён до `1`.  
    - Поэтому возвращает `[1, setIndex]`.
    
4. И так далее:  
    - Каждый вызов `setIndex` меняет сохранённое значение и вызывает новый рендер.

---
###### **Несколько переменных состояния в компоненте**
В React можно иметь любое количество переменных состояния разных типов внутри одного компонента.

---
###### **Как React сопоставляет переменные и состояния?**
Хуки полагаются на стабильный порядок вызовов при каждом рендере одного и того же компонента. Именно поэтому хуки вызываются только на верхнем уровне.

Внутри себя React хранит массив пар состояния для каждого компонента. Он также ведёт счётчик текущей пары, который устанавливается в `0` перед рендерингом. Каждый раз, когда вы вызываете `useState`, React выдаёт вам следующую пару состояния и увеличивает счётчик.

---
**Состояние изолировано и приватно**
Состояние является локальным для конкретного экземпляра компонента на экране. Другими словами, если вы отрендерите один и тот же компонент дважды, каждая копия будет иметь полностью изолированное состояние! Изменение одного из них никак не повлияет на другой.

Eсли вы хотите, чтобы компоненты синхронизировали свои состояния $-$ правильный способ сделать это в React $-$ удалить состояние из дочерних компонентов и перенести его в их ближайший общий родитель.
