###### **Репликация**
Репликация (replication) означает хранение копий одних и тех же данных на не-
скольких машинах, соединенных с помощью сети.

Причины:
- ради хранения данных географически близко к пользователям (и сокращения, таким образом, задержек);
- чтобы система могла продолжать работать при отказе некоторых ее частей (и повышения, таким образом, доступности)
- для горизонтального масштабирования количества машин, обслуживающих запросы на чтение (и повышения, таким образом, пропускной способности по чтению).

Основные сложности репликации заключаются в том, что делать с изменениями реплицированных данных. 

Алгоритмы репликации изменений:
- один ведущий узел (single-leader)
- несколько ведущих узлов (multi-leader)
- без ведущего узла (leaderless)

###### **Ведущие и ведомые узлы**
Узлы, в которых хранятся копии БД, называются репликами.

Каждая операция записи в базу должна учитываться каждой репликой, иначе нельзя гарантировать, что реплики содержат одни и те же данные. Наиболее распространенное решение этой проблемы называется репликацией с ведущим узлом (leader-based replication).
1. Одна из реплик назначается ведущим (leader) узлом. Клиенты, желающие записать данные в базу, должны отправить свои запросы ведущему узлу, который сначала записывает новые данные в свое локальное хранилище.
2. Другие реплики называются ведомыми (followers) узлами. Всякий раз, когда ведущий узел записывает в свое хранилище новые данные, он также отправляет информацию об изменениях данных всем ведомым узлам в качестве части журнала репликации (replication log) или потока изменений (change stream). Все ведомые узлы получают журнал от ведущего и обновляют соответствующим образом свою локальную копию БД, применяя все операции записи в порядке их обработки ведущим узлом.
3. Когда клиенту требуется прочитать данные из базы, он может выполнить запрос или к ведущему узлу, или к любому из ведомых. Однако запросы на запись разрешено отправлять только ведущему (ведомые с точки зрения клиента предназначены только для чтения).
![[Pasted image 20251105163318.png]]

###### **Синхронная и асинхронная репликация**
Важный фактор работы реплицируемой системы — синхронно или асинхронно
выполняется репликация.
![[Pasted image 20251105165009.png]]
На примере репликация на ведомый узел 1 синхронна: ведущий узел ждет до тех пор, пока ведомый узел 1 не подтвердит получение операции записи, прежде
чем сообщить пользователю об успехе и сделать результаты записи видимыми другим клиентам. Репликация на ведомый узел 2 асинхронна: ведущий узел отправляет сообщение, но не ждет ответа от ведомого.

###### **Создание новых ведомых узлов**
Зачем создают новые ведомые узлы:
- Для увеличения количества реплик или замены сбойных узлов.
- Необходимо гарантировать, что ведомый узел содержит точную копию данных ведущего.

Проблема:
- Простое копирование данных невозможно, так как база постоянно изменяется.
- Копии могут быть сделаны в разные моменты времени → данные несогласованы.
    
Решение:
- Можно заблокировать базу для копирования, но это снижает доступность.
- Поэтому создают согласованный снимок без остановки системы.
    
Этапы создания нового ведомого узла:
1. Создать согласованный снимок состояния БД ведущего узла
2. Скопировать снимок на новый ведомый узел
3. Подключить ведомый узел к ведущему
4. Наверстать упущенные изменения и перейти в режим обычной репликации

###### **Отказ ведомого узла: наверстывающее восстановление**
При сбое ведомый узел, опираясь на свой журнал изменений, после восстановления запрашивает у ведущего все данные, изменённые за время его недоступности, и догоняет состояние системы.

###### **Отказ ведущего узла: восстановление после отказа**
При отказе ведущего узла один из ведомых становится новым ведущим, а клиенты и остальные узлы перенастраиваются на работу с ним — это процесс восстановления после отказа (failover).

Он включает:
1. Обнаружение сбоя (по таймауту отклика).
2. Выбор нового ведущего — обычно реплики с самыми свежими данными.
3. Перенастройку системы на нового ведущего.

Проблемы:
- Потеря или конфликт данных при асинхронной репликации.
- Возможность появления двух ведущих (split-brain).
- Сложность выбора времени ожидания — слишком короткое вызывает ложные срабатывания, слишком длинное замедляет восстановление.
Из-за этих рисков часто применяют ручное восстановление.

###### **Перенос журнала упреждающей записи (WAL)**
Журнал репликации — это последовательность записей всех операций БД, дописываемых только в конец. Ведущий узел не только сохраняет журнал на диск, но и передаёт его ведомым, которые по нему воссоздают идентичные данные.

Такой подход используют, например, PostgreSQL и Oracle. Недостаток — журнал работает на низком уровне (байты и блоки), из-за чего репликация жёстко связана с форматом хранения. При обновлении версии БД ведущий и ведомые не могут работать на разных версиях, поэтому обновление системы требует простоя. Если же протокол позволяет разным версиям взаимодействовать, обновление можно проводить без остановки.

###### **Логическая (построчная) репликация**
Логическая (построчная) репликация использует журнал, описывающий изменения данных на уровне строк таблиц, а не на уровне байтов и блоков, как физическая репликация.

В журнал записывается:
- при вставке — все значения новой строки
- при удалении — идентификатор удалённой строки (обычно первичный ключ)
- при обновлении — идентификатор строки и новые значения изменённых столбцов.

Преимущества:
- не зависит от формата хранения данных    
- позволяет использовать разные версии или даже разные СУБД на ведущем и ведомых
- удобен для интеграции с внешними системами (аналитика, кэш, индексы) — через Change Data Capture (CDC)

**Триггерная репликация**
Триггерная репликация переносит логику репликации на уровень приложения, что даёт больше гибкости.

При изменении данных триггеры автоматически вызывают пользовательский код, который записывает изменения в отдельную таблицу. Внешний процесс затем читает эти данные и выполняет нужную логику (например, выборочные обновления, преобразования или репликацию в другую СУБД).

Недостатки — высокая нагрузка, риск ошибок и меньшая надёжность по сравнению со встроенной репликацией.  
Преимущество — гибкость: можно реплицировать часть данных, использовать разные типы баз и реализовывать собственные правила обработки конфликтов.