#### <mark style="background: #ABF7F7A6;">Выделение и освобождение памяти в стиле C++</mark>
В C++ для динамического выделения памяти (т.е. во время выполнения программы, а не на стеке) используются операторы:

#### `new` и `delete` — для одного объекта:
```cpp
int* ptr = new int(10);  // выделили память под int и записали 10
delete ptr;              // освободили память
```

#### `new[]` и `delete[]` — для массивов:
```cpp
int* arr = new int[5];   // массив из 5 элементов
delete[] arr;            // освобождение массива
```

Важно: `delete` используется **только** для `new`, и `delete[]` — **только** для `new[]`. Нельзя смешивать!

#### <mark style="background: #ABF7F7A6;">Типичные проблемы с динамической памятью</mark>
#### ==Утечка памяти (memory leak)==
Память выделили — а освободить забыли.
```cpp
int* p = new int(42);
// delete p;  // забыли — утечка!
```
Может накапливаться и привести к исчерпанию памяти.

#### ==Двойное удаление==
Если два указателя указывают на один объект:
```cpp
int* p = new int(10);
int* q = p;

delete p;
delete q; // неопределённое поведение — вторая попытка удаления
```

#### ==Использование удалённой памяти (dangling pointer)==
```cpp
int* p = new int(5);
delete p;

*p = 10; // обращение к уже освобождённой памяти — UB
```

#### ==Потеря указателя на выделенную память==
```cpp
int* p = new int(10);
p = nullptr;  // теперь мы не можем освободить память — потеряли ссылку
```

#### ==Нарушение границ массива==
```cpp
int* arr = new int[3];
arr[5] = 10;  // выход за границы массива
```

#### <mark style="background: #ABF7F7A6;">Как избежать этих проблем?</mark>
1. **RAII** (Resource Acquisition Is Initialization) — идиома, при которой ресурсы оборачиваются в объекты. Они освобождаются автоматически при выходе из области видимости.
2. **Умные указатели (`unique_ptr`, `shared_ptr`)** — избавляют от необходимости вручную вызывать `delete`.
3. **Избегать "сырого" `new` и `delete` там, где можно** — лучше использовать `vector`, `string`, `make_unique` и др.

