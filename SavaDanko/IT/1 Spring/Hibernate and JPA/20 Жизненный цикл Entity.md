---
tags:
  - review
sr-due: 2026-03-25
sr-interval: 85
sr-ease: 250
---

---
![[Pasted image 20251105143713.png]]

###### **Основные состояния**
1. New / Transient
    Просто новый объект `new User()`.
    - нет идентификатора из БД (или он не привязан к строке в БД);
    - `EntityManager` его не знает, изменения никто не отслеживает.  
        После коммита транзакции такой объект для JPA просто не существует.
        
2. Managed (Persistent)  
    Объект «под управлением» контекста сохранения.
    - получен через `find() / getReference()` или переведён через `persist()`        
    - привязан к строке в БД
    - любые изменения полей автоматически попадут в БД при `flush`/`commit`.
        
3. Detached
    Объект когда-то был managed, но связь с контекстом потеряна.
    - это случается после `commit/rollback`, `clear()`, `close()`, либо явного `detach()`
    - данные в объекте можно менять, но JPA их уже не сохранит, пока мы не «вернём» его.
        
4. Removed  
    Объект помечен на удаление.
    - вызван `remove()` для managed-сущности;
    - до `flush/commit` строка ещё существует в БД, но после коммита будет удалена.

###### **Переходы между состояниями (по стрелкам)**
- New → Managed — `persist()`
    Добавляем сущность в контекст: теперь она managed, и при коммите будет вставка в БД.
    
- Managed → Removed — `remove()`  
    Сущность отмечается как удаляемая. При коммите — `DELETE` в БД.
    
- Removed → Managed — `persist()`  
    Пока транзакция не зафиксирована, можно «передумать» и снова сделать сущность управляемой (по сути, отменить пометку на удаление).
    
- Managed → Detached — `commit / rollback`  
    После окончания транзакции текущий `EntityManager` очищается, и все его сущности становятся detached.
    
- Detached → Managed — `merge()`  
    Создаётся новый managed-объект с такими же данными (или обновляется уже существующий в контексте). С исходным detached-объектом JPA дальше ничего не делает.

- Managed → Managed — `refresh()`  
    Сущность перечитывается из БД, локальные несохранённые изменения откатываются к тому, что в базе.
    
- Removed → Detached — `rollback`  
    Если транзакцию с удалением откатить, удаление отменяется, и объект остаётся как обычный detached (его нужно заново присоединять через `merge()`/`persist()`).