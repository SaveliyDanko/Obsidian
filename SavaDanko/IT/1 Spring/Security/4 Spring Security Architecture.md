---
tags:
  - review
sr-due: 2026-02-27
sr-interval: 67
sr-ease: 250
---

---
![[Pasted image 20251109012726.png]]
На этой схеме показано, как Spring Security обрабатывает аутентификацию и авторизацию пользователя и какие компоненты в этом участвуют.

###### **Всё начинается с запроса**
Когда в приложение поступает HTTP-запрос, он сначала перехватывается цепочкой фильтров (Filter Chain). Эта цепочка содержит множество фильтров, каждый из которых выполняет свою задачу.

Одним из таких фильтров является `AuthenticationFilter` — фильтр аутентификации.

###### **Authentication Filter**
Его задача — перехватывать запросы логина, то есть те, где пользователь отправляет логин и пароль.

Когда фильтр обнаруживает такой запрос:
1. Он извлекает логин и пароль.
2. Создаёт объект `Authentication`, в котором упаковываются учётные данные пользователя (credentials) и информация о пользователе (principal).

Однако на этом этапе пользователь ещё не считается аутентифицированным — просто создан объект с переданными данными.

Далее фильтр передаёт этот объект в `AuthenticationManager`.

###### **Authentication Manager**
`AuthenticationManager` — это своего рода оркестратор, который решает, как именно нужно проверить введённые данные. Сам он проверку не выполняет, а делегирует её одному или нескольким `AuthenticationProvider`.

###### **Authentication Provider**
`AuthenticationProvider` — это компонент, который проверяет логин и пароль.
Может быть несколько таких провайдеров — например:
- один для проверки пользователей через базу данных
- другой — через LDAP
- третий — через токены (JWT) и т.д.

###### **DaoAuthenticationProvider (встроенный по умолчанию)**
По умолчанию Spring Security использует `DaoAuthenticationProvider`.
Он работает в связке с двумя важными компонентами:
- `UserDetailsService`
- `PasswordEncoder`

###### **UserDetailsService**
`UserDetailsService` — это интерфейс, который загружает данные пользователя (логин, пароль, роли и т.д.) из источника данных — например, из базы.
Метод `loadUserByUsername()` получает пользователя по логину и возвращает объект `UserDetails`.

Эта информация нужна, чтобы сравнить введённые пользователем учётные данные с теми, что сохранены в базе.

###### **PasswordEncoder**
Пароли не хранятся в открытом виде, поэтому используется `PasswordEncoder`.  
Он:
- шифрует пароль при сохранении.
- сравнивает (метод `matches`) зашифрованный пароль из базы с введённым пользователем.

Если проверка прошла успешно — пользователь считается аутентифицированным.

###### **Создание «полного» Authentication Object**
Когда `AuthenticationProvider` подтверждает правильность логина и пароля:
1. Он обновляет объект `Authentication`, созданный фильтром.    
2. Добавляет в него роли и другие данные из базы.
3. Помечает пользователя как authenticated = true.
    
Теперь объект `Authentication` полностью содержит:
- информацию о запросе
- имя пользователя
- учётные данные
- роли и права

###### **SecurityContext**
После успешной аутентификации обновляется Security Context — специальный контекст, который существует в течение всего запроса.

Обновлённый `Authentication` помещается в `SecurityContextHolder`.  
Теперь все последующие запросы этого пользователя будут автоматически считаться выполненными от имени аутентифицированного пользователя.

###### **Последующие запросы**
Так как пользователь уже прошёл проверку, при следующих обращениях Spring Security берёт данные из `SecurityContext` и не требует повторного входа (пока сессия активна).

###### **Переход к контроллерам**
После обновления контекста запрос передаётся дальше — в `DispatcherServlet`, а затем — в контроллеры твоего приложения, где выполняется бизнес-логика.