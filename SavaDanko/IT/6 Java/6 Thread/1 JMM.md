---
tags:
  - review
sr-due: 2026-02-02
sr-interval: 25
sr-ease: 250
---
---
[Article](https://habr.com/ru/articles/685518/)

---
В современном мире код часто выполняется не в том порядке, в котором он был написан в программе. Также в современных процессорах каждое ядро имеет собственный локальный кэш, который не видим другим ядрам. Более того, записи могут удерживаться в регистрах процессора, а не сбрасываться в память. Это ведет к тому, что поток может не видеть изменений, сделанных из других потоков.

###### Java as-if-serial
Независимо от того, насколько агрессивно JVM/JIT/CPU переупорядочивают и оптимизируют инструкции, каждый отдельный поток должен вести себя так, как если бы его операторы выполнялись в исходном порядке программы.

Это свойство известно как принцип as-if-serial: оптимизации допустимы, пока они не меняют наблюдаемое поведение внутри одного потока.

###### Cache coherence
[[27 Cache coherence]]

###### MESI
MESI — это один из самых распространённых протоколов когерентности кэшей, используемых в многоядерных CPU для поддержания согласованности кэшей каждого ядра.  
Он работает на уровне кэш-линии: каждая закэшированная линия помечается одним из четырёх состояний.

M — Modified (изменена)
- Это ядро имеет единственную копию строки, и она грязная (отличается от RAM).
- Основная память содержит устаревшее значение, пока строка не будет записана обратно.

E — Exclusive (эксклюзивная)
- Это ядро имеет единственную копию строки, но она чистая (совпадает с RAM).

S — Shared (разделяемая)
- Несколько ядер могут иметь чистую копию строки.

I — Invalid (недействительная)
- В этом кэше нет валидной копии данной строки.

###### Store buffer
Store buffer (буфер записей) — это небольшая аппаратная очередь на каждом ядре, в которой хранятся ожидающие записи (store) до того, как они станут видимыми в кэш-иерархии ядра и для других ядер.

Если бы каждая операция `store` была обязана ждать, пока ядро:
1. получит кэш-линию в состоянии exclusive/modified (MESI)
2. обновит L1-кэш
3. завершит трафик когерентности (инвалидации / подтверждения)
— конвейер процессора постоянно простаивал бы

Поэтому CPU делает иначе:
- быстро помещает запись в store buffer (инструкция считается выполненной / retired)
- а затем сбрасывает (drain) буфер в кэш и систему когерентности в фоне

Это даёт огромный выигрыш в производительности.
![[Pasted image 20251219012528.png]]

###### Instruction reordering
Переупорядочивание инструкций (instruction reordering) в Java — это ситуация, когда компилятор, JIT или процессор изменяют фактический порядок выполнения или видимости операций по сравнению с тем порядком, в котором они написаны в исходном коде, не изменяя того, что может наблюдать один поток.

Java допускает это, потому что такие переупорядочивания позволяют выполнять существенные оптимизации (кэширование значений в регистрах, перемещение операций чтения/записи, внеочередное выполнение инструкций на CPU и т. д.).

Однако эти оптимизации становятся заметными и потенциально опасными, когда несколько потоков разделяют данные без корректной синхронизации.

###### Java Memory Model
Java Memory Model (JMM) — это набор правил, определяющих, какие значения операция чтения имеет право увидеть в многопоточной Java-программе, учитывая, что компиляторы, JIT и CPU могут переупорядочивать инструкции и выполнять оптимизации.
JMM не описывает, как именно JVM исполняет программу — она определяет, какие результаты исполнения считаются допустимыми.

###### Memory ordering
Упорядочивание памяти (memory ordering) — это вопрос о том, в каком порядке операции чтения и записи становятся видимыми другим потокам.
Даже если в вашем коде явно написано:
```
x = 42; 
ready = true;
```
другой поток не обязан наблюдать эти записи именно в таком порядке, если вы не создали отношение happens-before в терминах JMM (с помощью `volatile`, `synchronized`, блокировок, атомарных типов и т. п.). Java Memory Model формально определяет, какие переупорядочивания и какие наблюдаемые результаты являются допустимыми.

###### Memory reordering
Переупорядочивание памяти (memory reordering) — это ситуация, когда JVM/JIT и/или процессор делают так, что операции с памятью (чтения и записи) выглядят так, будто они произошли в другом порядке, чем тот, в котором вы их написали в коде, с точки зрения других потоков.

Java допускает множество переупорядочиваний ради производительности, а Java Memory Model (JMM) определяет, какие наблюдаемые результаты являются допустимыми, а какие запрещены — через правила `happens-before`.

###### Классические 4 типа переупорядочивания
Названия происходят от двух операций с памятью, порядок которых может быть поменян местами (или выглядеть поменянным при наблюдении из другого потока).  

Load → Load (LoadLoad)
Более позднее чтение становится видимым или выполняется раньше более раннего чтения.

Load → Store (LoadStore)
Более поздняя запись выглядит так, будто она произошла раньше предыдущего чтения.

Store → Store (StoreStore)
Две записи становятся видимыми другим потокам в обратном порядке.

Store → Load (StoreLoad) — «самый сложный»
Чтение после записи выглядит так, будто оно произошло до того, как запись стала видимой для других потоков.


###### Memory Ordering vs Instructions Ordering
Еще раз закрепим: Memory Ordering и Instructions Ordering — это не одно и то же. Инструкции могут переупорядочиваться под капотом как угодно, но их memory effect должен подчиняться некоторым Memory Ordering правилам, которые гарантируются (или не гарантируются) Memory Model. Наконец, memory ordering — это высокоуровневое понятие, созданное для простоты понимания работы с памятью.

Например, Intel запрещает `LoadLoad` переупорядочивания, но под капотом все равно делает спекулятивные чтения. Как это возможно? Дело в том, что процессор следит за тем, чтобы результат выполнения инструкций не нарушал memory ordering правил. Если какое-то правило нарушается, то процессор возвращается к более раннему состоянию: результат чтения отбрасывается, а записи не коммитятся в память.

###### Последовательная согласованность (Sequential Consistency, SC)
Модель последовательной согласованности (SC) — это классическая модель памяти/согласованности для конкурентных систем. Она утверждает:
Исполнение является последовательно согласованным, если его результат такой же, как если бы операции всех потоков выполнялись в одном единственном последовательном порядке, и при этом операции каждого потока появляются в этом порядке в соответствии с их порядком в программе.

Иными словами, представьте себе единую глобальную временную линию операций с памятью (чтений и записей). Система может произвольно чередовать операции разных потоков, но никогда не должна «перемешивать» порядок операций внутри одного потока.

###### Data race
Гонка данных (data race) в терминах JMM возникает, когда:
- два потока выполняют конфликтующие обращения к одной и той же переменной
- хотя бы одно из этих обращений — запись
- и между этими обращениями нет отношения happens-before

###### Синхронизационные действия (Synchronization actions)
Синхронизационные действия (synchronization actions) — это специальные операции, с помощью которых модель задаёт межпоточную видимость и упорядочивание.

В JLS определяются межпоточные действия (inter-thread actions), и указывается, что синхронизационные действия — это их подмножество. К синхронизационным действиям относятся:
- Чтение `volatile`
- Запись `volatile`
- Захват блокировки (`lock`, вход в монитор)
- Освобождение блокировки (`unlock`, выход из монитора)
- (Синтетические) первое и последнее действие потока
- Действия, которые запускают поток или обнаруживают его завершение
Обычные чтения и записи не-volatile полей тоже являются inter-thread actions, но не являются синхронизационными действиями — поэтому сами по себе они не создают гарантий видимости и порядка между потоками.

###### Порядок синхронизации (Synchronization order)
Порядок синхронизации (synchronization order) — это глобальный порядок, который JMM присваивает этим действиям в конкретном исполнении.

JLS: каждое исполнение имеет порядок синхронизации, который является полным порядком всех синхронизационных действий в этом исполнении и должен быть согласован с порядком программы каждого потока (для его синхронизационных действий).


###### Happens-before (HB)
Happens-before — это формальное отношение в Java Memory Model, задающее гарантии видимости и упорядочивания между действиями.

Если A happens-before B, то все эффекты A гарантированно видимы для B, и A считается упорядоченным перед B.

###### Важные свойства HB
- HB — частичный порядок: не все действия в программе упорядочены друг относительно друга.
- HB ≠ реальное время (wall-clock time): даже при наличии HB-связи JVM/CPU могут выполнять внутренние переупорядочивания, если наблюдаемый результат соответствует допустимому исполнению по JMM.
- HB определяет что разрешено наблюдать, а не как именно исполняется код.

###### Что создаёт отношение happens-before
HB строится из двух источников:
1. Порядок программы (program order) — внутри одного потока
2. Синхронизационные связи (synchronizes-with) — между потоками
И далее расширяется транзитивностью.

###### Happens-before внутри одного потока (program order)
Если действия `x` и `y` выполняются в одном и том же потоке, и `x` идёт раньше `y` в порядке программы, то: hb(x, y)
Это верно всегда, независимо от оптимизаций и переупорядочиваний.

###### Happens-before между потоками (через синхронизацию)
Мониторы (`synchronized`)
- Выход из монитора (unlock) → последующий вход (lock)    
- Применяется только к одному и тому же монитору

`volatile`
- Запись в `volatile`-переменную → последующее чтение той же `volatile`-переменной

Потоки
- `Thread.start()` → первое действие в запущенном потоке    
- Все действия в потоке → обнаружение его завершения другим потоком (например, `join()` или `isAlive()`)

Прерывания
- Вызов `interrupt()` → обнаружение прерывания (`InterruptedException`, `interrupted()`, `isInterrupted()`)

###### Транзитивность happens-before
Если hb(x, y) и hb(y, z), то hb(x, z)
Именно транзитивность делает возможной безопасную публикацию данных.

###### Формальное определение
Пусть есть потоки `T1` и `T2` (возможно, один и тот же поток) и действия `x` и `y`.
Если `x happens-before y`, то:
- во время выполнения `y`
- и во всех действиях, идущих после `y` в порядке программы
потоку `T2` гарантированно видны все изменения, выполненные потоком `T1`:
- в действии `x`
- и во всех действиях, которые предшествуют `x` в порядке программы

###### Mutex
Mutex — это примитив синхронизации, который гарантирует, что в каждый момент времени только один поток может войти в критическую секцию.

###### Барьер памяти (memory barrier)
Барьер памяти (memory barrier), также называемый memory fence, — это механизм, который запрещает определённые виды переупорядочивания операций с памятью и/или принудительно обеспечивает видимость записей между ядрами.

###### JMM Atomicity
В Java Memory Model (JMM) атомарность (atomicity) отвечает на вопрос:
Может ли одна операция быть наблюдена другим потоком наполовину выполненной, или она происходит как одно неделимое действие?

Что в Java является атомарным:
- Чтения и записи ссылок всегда атомарны.
- Чтения и записи большинства примитивных типов атомарны: `boolean`, `byte`, `short`, `char`, `int`, `float`
- Любая переменная, объявленная `volatile`, имеет атомарные чтения и записи, включая `volatile long` и `volatile double`