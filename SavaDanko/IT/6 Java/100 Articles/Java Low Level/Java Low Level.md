[[Basics]]
[[JVM]]
[[JRE]]
[[JDK]]
[[Java Low Level]]

---
## 1. Введение в платформу Java

1. **Основные составляющие Java-платформы**
    
    - **JDK** (Java Development Kit): компилятор (`javac`), инструменты (отладчик, профилировщик и пр.), стандартная библиотека.
        
    - **JRE** (Java Runtime Environment): виртуальная машина (JVM), базовые библиотеки и другие ресурсы.
        
    - **JVM** (Java Virtual Machine): интерпретатор/исполнитель байткода с JIT-компиляцией.
        

---

## 2. Общая архитектура JVM

1. **Задачи виртуальной машины**
    
    - Выполнение байткода.
        
    - Управление памятью (куча, стек, метод-арея и пр.).
        
    - Безопасность выполнения (проверка байткода и классов).
        
2. **Основные компоненты JVM**
    
    - **Class Loader Subsystem** (подсистема загрузки классов).
        
    - **Runtime Data Areas** (области памяти в процессе выполнения).
        
    - **Execution Engine** (интерпретатор, JIT-компилятор, профилировщик).
        
    - **Native Interface** (JNI).
        
    - **Garbage Collector** (модули сборки мусора).
        
3. **Различные реализации JVM**
    
    - HotSpot, OpenJ9, Azul Zing и т.д.
        
    - Отличия в реализациях сборщика мусора, оптимизациях, лицензировании.
        

---

## 3. Подсистема загрузки классов (Class Loader Subsystem)

1. **Этапы загрузки классов**
    
    - Загрузка (Loading).
        
    - Проверка (Verification).
        
    - Подготовка (Preparation).
        
    - Разрешение (Resolution).
        
    - Инициализация (Initialization).
        
    - Использование (Using).
        
    - Завершение (Unloading).
        
2. **Типы загрузчиков классов**
    
    - **Bootstrap Class Loader** (загружает базовые классы из `rt.jar` или `classpath` модулей).
        
    - **Extension (Platform) Class Loader** (загружает расширения).
        
    - **System (Application) Class Loader** (загружает классы приложения по пути `classpath`).
        
    - Пользовательские (кастомные) загрузчики (например, для плагинов, OSGi, модульных систем).
        
3. **Принцип делегирования** (Delegation Model)
    
    - Родительская иерархия загрузчиков.
        
    - Проблемы с двойной загрузкой (рассогласование классов) и способы их решения.
        
4. **Динамическая загрузка классов**
    
    - Reflection API (`Class.forName`, `ClassLoader.loadClass`).
        
    - Генерация и загрузка классов «на лету» (например, через библиотеки ASM, Javassist).
        
5. **Безопасность и верификация байткода**
    
    - Bytecode Verifier: проверка корректности структуры байткода, переменных, типов и т.д.
        

---

## 4. Модель памяти Java (Runtime Data Areas)

1. **Общие понятия**
    
    - **Method Area (или Metaspace в современных JVM)**
        
    - **Heap (Куча)**
        
    - **JVM Stack (Стек потоков)**
        
    - **PC Register** (регистр счётчика выполнения).
        
    - **Native Method Stacks** (при работе с JNI и нативным кодом).
        
2. **Metaspace (или PermGen в старых версиях Java)**
    
    - Хранение метаданных классов, методов.
        
    - Разница между PermGen (до Java 8) и Metaspace (начиная с Java 8).
        
    - Настройки размера и влияние на работу JVM.
        
3. **Структура кучи**
    
    - **New (Young) Generation**: Eden, Survivor Spaces (S0, S1).
        
    - **Old Generation** (Tenured).
        
    - **Large Object Space** (в некоторых реализациях).
        
    - Пулы объектов, выделение памяти, частая аллокация.
        
4. **Структура стека**
    
    - **Stack Frames**: локальные переменные, операнды, ссылки на объекты и т.д.
        
    - Жизненный цикл фреймов: создание при вызове метода, удаление при возвращении.
        
5. **Потоки (Threads) и их взаимодействие с памятью**
    
    - Каждый поток имеет свой стек.
        
    - Видимость изменений через модель памяти (Java Memory Model, JMM).
        
    - Синхронизация (volatile, synchronized, locks).
        

---

## 5. Java Memory Model (JMM) и многопоточность

1. **Основные принципы Java Memory Model**
    
    - Последовательность видимости данных, порядок чтения/записи.
        
    - Happens-before отношения.
        
    - Role of `volatile`, `synchronized`, `final`.
        
2. **Синхронизация в Java**
    
    - Ключевое слово `synchronized`, блокировки (intrinsic locks).
        
    - Специальные классы из `java.util.concurrent` (ReentrantLock, Semaphore, CountDownLatch и т.д.).
        
    - Atomics (AtomicInteger, AtomicReference и др.).
        
3. **Проблемы видимости и reorderings**
    
    - Как процессор и компилятор могут переставлять операции.
        
    - Барьеры памяти (Memory Barriers/Fences).
        
4. **Parallel Streams и Fork/Join Framework**
    
    - Архитектура, Work Stealing.
        
    - Взаимодействие с JMM.
        

---

## 6. Подсистема исполнения (Execution Engine)

1. **Интерпретатор**
    
    - Разбор байткода, исполнение инструкций.
        
    - Основные инструкции байткода (aload, astore, iadd, invokevirtual и т.д.).
        
2. **Just-In-Time (JIT) компиляция**
    
    - **C1 (client) компилятор** и **C2 (server) компилятор** в HotSpot.
        
    - Профилирование кода: сбор статистики на «горячих» участках.
        
    - Оптимизации JIT: инлайнинг, разворачивание циклов, константная пропагация и т.д.
        
    - Проблемы «долгого разогрева» (warm-up).
        
3. **Интерпретация против компиляции**
    
    - Trade-offs: скорость старта vs. производительность длительного выполнения.
        
    - GraalVM JIT (новая реализация компилятора).
        
4. **AOT (Ahead-Of-Time) компиляция**
    
    - GraalVM Native Image.
        
    - Преимущества и ограничения AOT в контексте Java.
        
    - Использование в микросервисах (быстрый старт).
        
5. **Профилировщики и мониторинг**
    
    - `jmap`, `jstack`, `jvisualvm`, `jconsole`, `jcmd`.
        
    - Сбор heap dump, thread dump.
        
    - Инструменты для анализа производительности (Flight Recorder, Mission Control).
        

---

## 7. Байткод Java (Java Bytecode)

1. **Структура `*.class` файлов**
    
    - Магическое число, версионность.
        
    - Constant Pool (таблица констант).
        
    - Метаданные о классах, методах, полях.
        
    - Байткод-секции каждого метода.
        
2. **Инструкции байткода**
    
    - Категории инструкций: загрузка/сохранение, арифметика, логика, ветвления, вызов методов, работа с объектами.
        
    - Управление стеком.
        
    - Особенности работы с примитивами и ссылочными типами.
        
3. **Верификатор байткода**
    
    - Проверка корректности стека, типов, корректности переходов.
        
    - Безопасность исполнения (исключение некорректного кода).
        
4. **Инструменты для анализа и генерации байткода**
    
    - `javap` (дизассемблирование).
        
    - ASM, BCEL, Javassist (динамическая генерация и трансформация).
        

---

## 8. Сборка мусора (Garbage Collection)

1. **Назначение и общий принцип GC**
    
    - Автоматическое освобождение неиспользуемых объектов в куче.
        
    - Корни (GC Roots): локальные переменные стека, статические поля, активные потоки и т.д.
        
2. **Различные алгоритмы и реализации GC**
    
    - **Serial GC** (один поток, простота).
        
    - **Parallel GC** (несколько потоков, ориентирован на throughput).
        
    - **CMS (Concurrent Mark-Sweep)** (устарел, но важен для понимания).
        
    - **G1 (Garbage-First)** (распределённый подход, региональное выделение).
        
    - **ZGC** (низкие задержки, масштабируемость).
        
    - **Shenandoah** (подобен ZGC, низкая пауза).
        
3. **Фазы и механика работы GC**
    
    - **Mark**: обход графа объектов.
        
    - **Sweep**: очистка памяти.
        
    - **Compact**: дефрагментация (не всегда присутствует).
        
    - **Copying** (применяется в молодом поколении).
        
4. **Настройки и тюнинг GC**
    
    - Параметры (Xmx, Xms, Xmn, NewRatio, SurvivorRatio и пр.).
        
    - Выбор сборщика мусора (`-XX:+UseG1GC`, `-XX:+UseZGC` и пр.).
        
    - Логирование GC (PrintGCDetails, PrintGCDateStamps).
        
    - Анализ логов, инструменты визуализации.
        
5. **Влияние GC на производительность**
    
    - Паузы (Stop-The-World).
        
    - Баланс между Throughput, Latency, Footprint.
        

---

## 9. Classpath и модули

1. **Classpath**
    
    - Как JVM ищет классы.
        
    - Задача `-cp`/`-classpath`, пути к библиотекам (JAR-файлы, директории).
        
    - Проблема «jar hell», дублирование версий библиотек.
        
2. **Модульная система (Java Platform Module System, JPMS)**
    
    - Нововведение Java 9.
        
    - Файл `module-info.java`.
        
    - Сильная инкапсуляция, зависимости между модулями, layer-слои.
        
    - Migration с classpath на module path.
        
3. **Инструменты для управления зависимостями**
    
    - Maven, Gradle.
        
    - Упаковка артефактов, публикация, транситивные зависимости.
        

---

## 10. Безопасность в JVM

1. **Security Manager** (до Java 17)
    
    - Разрешения (Policy Files).
        
    - Запуск «песочниц» (Sandbox) с ограниченными правами.
        
2. **ClassLoader и безопасность**
    
    - Подделка классов, защита от несанкционированных загрузок.
        
    - Делегирование и проверка.
        
3. **Криптография и управление ключами**
    
    - Java Cryptography Architecture (JCA).
        
    - Java Cryptography Extension (JCE).
        
    - KeyStore, TrustStore.
        
4. **Управление безопасностью в средах продакшн**
    
    - Контейнеры, Docker, Kubernetes.
        
    - Ограничения на уровне операционной системы.
        

---

## 11. JNI и взаимодействие с нативным кодом

1. **Java Native Interface**
    
    - Причины использования: производительность, доступ к системным API, реюз кода на C/C++.
        
    - Объявление нативных методов (`native`), генерация заголовков (`javah`).
        
    - Жизненный цикл, вызовы из Java в C/C++ и обратно.
        
2. **Связывание и загрузка нативных библиотек**
    
    - Метод `System.loadLibrary()`, поиск библиотек.
        
    - Проблемы совместимости по платформам.
        
3. **Альтернативные технологии взаимодействия**
    
    - JNA (Java Native Access).
        
    - Panama Project (в будущем упрощённое взаимодействие с нативными библиотеками).
        
4. **Безопасность и производительность JNI**
    
    - Ограничения при работе с памятью вне кучи.
        
    - Издержки вызовов через JNI.
        

---

## 12. Отладка и профилирование

1. **Инструменты командной строки**
    
    - `javac`, `java`, `jlink`, `jpackage`.
        
    - `jps`, `jinfo`, `jmap`, `jstack`, `jcmd`.
        
    - `jstat` (статистика памяти и GC).
        
2. **Инструменты визуального профилирования**
    
    - **VisualVM**, **JConsole**, **Java Mission Control**, **Flight Recorder**.
        
    - Подключение к удалённым JVM.
        
3. **Съём дампов памяти, потоков, CPU**
    
    - Heap dump, Thread dump, профилирование CPU, памяти, мониторинга ожиданий (locks).
        
    - Анализ файлов дампа (MAT – Memory Analyzer Tool).
        
4. **Особенности профилирования высоконагруженных систем**
    
    - Тонкая настройка сбора метрик.
        
    - Минимизация overhead при профилировании (sampling vs. instrumentation).
        

---

## 13. Управление процессом выполнения (Monitoring & Management)

1. **Java Management Extensions (JMX)**
    
    - MBeans, платформенные бины (MemoryMXBean, ThreadMXBean и т.д.).
        
    - Регистрация кастомных MBean.
        
    - Подключение JConsole/JVisualVM через JMX.
        
2. **Inspection и Diagnostics**
    
    - Diagnostic Commands (`jcmd`).
        
    - HotSpot Diagnostic MBean.
        
3. **Производственные инструменты**
    
    - Средства логирования (Log4j, JUL, SLF4J), сбор метрик (Micrometer, Prometheus).
        
    - Трассировка (opentracing, zipkin, Jaeger).
        
4. **Event-based мониторинг**
    
    - Java Flight Recorder, события уровня JVM.
        
    - Анализ event-логов.
        

---

## 14. Оптимизации и внутренние механизмы JVM

1. **JIT-оптимизации**
    
    - Инлайнинг методов, удаление геттеров/сеттеров.
        
    - Loop unrolling, Escape Analysis.
        
    - Предсказание ветвлений (branch prediction).
        
2. **Escape Analysis**
    
    - Выявление объектов, которые «не утекают» за пределы метода/потока.
        
    - Scalar replacement (размещение объекта на стеке).
        
3. **Tiered Compilation**
    
    - Сочетание C1 и C2 компиляторов.
        
    - Динамическое переключение уровней оптимизации.
        
4. **Graаl Compiler**
    
    - Архитектура, преимущества по сравнению с C2.
        
    - Возможность использования Graal как JIT и как AOT.
        
5. **Распределённые и облачные окружения**
    
    - Быстрый старт (критичен для Serverless/FaaS).
        
    - Поддержка контейнеров (ограниченные ресурсы, cgroup).
        

---

## 15. Дополнительные темы и углублённые аспекты

1. **Reflection, Dynamic Proxy, Unsafe**
    
    - Механизм отражения (reflection), создание объектов через рефлексию.
        
    - Генерация динамических прокси (java.lang.reflect.Proxy).
        
    - `sun.misc.Unsafe` (низкоуровневый доступ к памяти, ограничения).
        
    - VarHandle (Java 9+) как более безопасный аналог.
        
2. **Аннотации и метаданные**
    
    - Встроенные аннотации (Override, Deprecated, FunctionalInterface).
        
    - Пользовательские аннотации (Retention, Target, Inherited).
        
    - Обработка аннотаций во время компиляции (Annotation Processing API).
        
3. **Class Redefinition и HotSwap**
    
    - Инструментальное API (Instrumentation).
        
    - Debug и HotSwap в IDE (ограничения).
        
    - Плагины (JRebel) для горячей замены кода.
        
4. **Реализация лямбд (Java 8+)**
    
    - InvokeDynamic, LambdaMetaFactory.
        
    - Генерация анонимных классов на лету или использование динамических вызовов.
        
5. **Project Loom (предварительные версии)**
    
    - Лёгкие потоки (Lightweight Threads / Fibers).
        
    - Continuations и изменение планировщика потоков в JVM.
        
6. **Метод-ручки (Method Handles) и invokedynamic**
    
    - Гибкий механизм вызова методов, динамические связки.
        
    - Использование в реализации лямбд, динамических языков на JVM (Scala, Kotlin, JRuby, Jython).
        

---

## 16. Практические примеры и Best Practices

1. **Рекомендации по тюнингу JVM**
    
    - Выбор GC, конфигурация памяти, размер Metaspace.
        
    - Типичные флаги JVM (`-XX:+UseG1GC`, `-XX:MaxGCPauseMillis`, `-XX:ParallelGCThreads` и др.).
        
2. **Отладка утечек памяти**
    
    - Использование профилировщиков, heap dump.
        
    - Common pitfalls (ThreadLocal, статические поля, Singleton).
        
3. **Оптимизация байткода и уровня кода**
    
    - Уменьшение количества выделений объектов.
        
    - Эффективная реализация equals/hashCode.
        
    - Понимание inlining и Escape Analysis.
        
4. **Безопасность и защита кода**
    
    - Кодирование ключей, секретов.
        
    - Утечки класса `java.lang.ClassLoader` и рефлекшн-баги.
        
5. **Архитектурные решения**
    
    - Микросервисы vs. монолиты.
        
    - Контейнеризация и impact на JVM-параметры (Memory limit, CPU quota).
        

---

## 17. Заключение и перспективы развития

1. **Новые возможности в свежих релизах Java**
    
    - Pattern Matching (switch, records, sealed classes).
        
    - Foreign Memory Access API (Project Panama).
        
    - Улучшения в профилировке и инструментировании.
        
2. **Будущее JVM**
    
    - Стандарты (JEPs) в рассмотрении: улучшения GC, Valhalla (Value Types).
        
    - Расширения проектами Graal, Substrate VM, Metropolis.
        
    - Конкуренция с другими платформами (.NET, Go, Rust).
        
3. **Преимущества и недостатки платформы Java**
    
    - Кроссплатформенность, зрелость экосистемы.
        
    - Скорость старта, потребление памяти.
        
    - Являются ли эти минусы критичными в современных реалиях?
        

---

### Как использовать этот список

Данный перечень охватывает всю «внутреннюю кухню» Java: от истории развития и базовой структуры JVM до глубокой оптимизации на уровне JIT и байткода. При написании статьи вы можете:

- Сгруппировать близкие по смыслу темы и объединять их в крупные блоки.
    
- Расставить акценты на тех аспектах, которые наиболее важны для вашей аудитории (разработчики, архитекторы, DevOps-инженеры и т.д.).
    
- Привести практические примеры (пример конфигурации GC, снимки профилей, анализ дампов).
    
- Подкрепить теорию советами и best practices из реальных проектов.
    

Такой подробный план позволит сделать вашу статью практически энциклопедической по охвату аспектов внутреннего устройства Java.