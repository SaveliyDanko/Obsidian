---
tags:
  - review
  - java
sr-due: 2026-07-30
sr-interval: 199
sr-ease: 290
---

---
###### [Руководство по модификатору static в Java](https://topjava.ru/blog/rukovodstvo-po-modifikatoru-static-v-java)


---
###### Анатомия ключевого слова static
В языке программирования Java ключевым словом `static` помечают принадлежащие классу, а не его экземпляру элементы (члены) класса.

Это означает, что какое бы количество объектов вы не создали, всегда будет создан только один член, доступный для использования всеми экземплярами класса.  

Ключевое слово static применимо к переменным, методам, блокам инициализации, импорту и вложенным классам (nested classes).

###### Статические поля (переменные класса)
В языке Java, если поле объявляется статическим (путем добавления модификатора static), то в независимости от количества созданных объектов класса — всегда будет существовать только один экземпляр статического поля. Значение такого поля будет единым и общим для всех объектов класса, содержащих это поле.

Статические переменные могут быть созданы только, как переменные класса. Они не могут быть локальными переменными.

С точки зрения используемой памяти, статические переменные размещаются в специальном пуле в памяти JVM, называемом Metaspace.

Несмотря на то, что получить доступ к статическим полям можно с помощью ссылки на объект (например, car1.numberOfCars), мы должны воздерживаться от её применения, поскольку в этом случае становится не совсем понятно, является ли эта переменная переменной экземпляра или же переменной класса. Вместо этого всегда необходимо ссылаться на статические переменные, используя имя класса (например, Car.numberOfCars).
```java
// Рекомендуется
System.out.println("Результат: " + Car.numberOfCars);

// Не рекомендуется, но работает
System.out.println("Результат: " + car1.numberOfCars);
```

###### Сериализация статических полей
Статические поля не сериализуются (как и `transient`-переменные). При десериализации такие поля будут иметь значения по умолчанию, заданные JVM при создании объекта

Во время десериализации, значение статической переменной может быть выведено, если эта статическая переменная была определена при инициализации базового класса. Это означает, что статическая переменная будет проинициализирована с тем же самым значением, которое было при загрузке класса.

Если переменная определена как static и transient, то модификатор static управляет поведением переменной, а не transient. Если мы присвоили такой переменной значение во время загрузки класса, то это значение будет присвоено статической переменной во время десериализации.

###### Статические методы (методы классов)
Подобно статическим полям, статические методы также принадлежат классу, а не объекту, поэтому их можно вызывать без создания экземпляра класса, в котором они находятся. При этом следует помнить, что из статического метода можно получить доступ только к статическим переменным или к другим статическим методам.

Статические методы в Java вызываются во время компиляции. Поскольку переопределение метода является частью полиморфизма во время выполнения (Runtime Polymorphism), статические методы не могут быть переопределены. Это справедливо также для статических методов интерфейса.

###### Статические методы в интерфейсах
В версии Java 8 появилась возможность определения статических методов в интерфейсах. Их поведение напоминает поведение методов по умолчанию (default methods), но есть существенные отличия – они не могут быть переопределены методами в реализующих интерфейс классах. Такая особенность позволяет избежать нежелательных результатов, которые возможны в случае некорректной реализации метода в классе.

###### Статический импорт
В Java 1.5 появилась реализация импорта статических переменных и статических методов класса, что позволяет обращаться к статическим членам класса непосредственно по имени члена, без дополнительного указания имени класса и пакета. Основная цель статического импорта — улучшение читабельности кода программы благодаря устранению постоянного повторения имени класса.  

Реализуется статический импорт на основе декларации `static import`, с последующим указанием импортируемого класса. Например так:
```java
import static java.util.Arrays.asList;
```

###### Статический блок инициализации
Статический блок используется для инициализации статических переменных. Хотя статические переменные могут быть инициализированы непосредственно во время объявления, бывают ситуации, когда нам требуется выполнить многострочную обработку.  

В таких случаях пригодятся статические блоки.  

Либо, если статические переменные во время инициализации требуют дополнительной логики, состоящей из нескольких операторов, то также можно использовать статический блок.
```java
public class StaticBlockDemo {
    public static List<String> ranks = new LinkedList<>();
    
    static {
        ranks.add("Lieutenant");
    	ranks.add("Captain");
    	ranks.add("Major");
    }
  	 
    static {
        ranks.add("Colonel");
        ranks.add("General");
    }
}
```

###### Статический вложенный класс (nested class)
Язык программирования Java позволяет создавать классы внутри другого класса. Такой класс называется вложенным (`nested`). Вложенный класс группирует элементы, которые будут использоваться в одном месте, сделав тем сам код более организованным и читабельным.  

Вложенные классы бывают двух видов:  
- вложенные классы, объявленные статическими, называются статическими вложенными классами (`static nested classes`)
- вложенные классы, объявленные без `static`, называются внутренними классами (`inner classes`)

Основное различие между этими понятиями состоит в том, что внутренние классы имеют доступ ко всем членам включающего их класса (включая приватные) верхнего уровня, тогда как статические вложенные классы имеют доступ только к статическим членам внешнего класса.

###### Константы
Говоря о ключевом слове `static`, нельзя не упомянуть о его применении в определении констант — переменных, которые никогда не изменяются.  

В языке Java существует зарезервированное слово `const`, но оно не используется, и Java не поддерживает константы на уровне языка. Выход из ситуации имеется: для определения константы необходимо добавить модификаторы `static final` к полю класса.  

Константы — это статические финальные поля, содержимое которых неизменно. Это относится к примитивам, String, неизменяемым типам и неизменяемым коллекциям неизменяемых типов. Если состояние объекта может измениться, он не является константой.

Модификатор `static` делает переменную доступной без создания экземпляра класса, а `final` делает ее неизменяемой. При этом нужно помнить, что если мы сделаем переменную только `static`, то ее легко можно будет изменить, обратившись к ней через имя класса. Если переменная будет иметь только модификатор final, то при создании каждого экземпляра класса она может быть проинициализирована своим значением. Соответственно, используя совместно модификаторы `static` и `final`, переменная остается статической и может быть проинициализирована только один раз. В Java константой считается не та переменная, которую нельзя изменить в рамках одного объекта, а та, которую не могут изменить ни один экземпляр класса в котором она находится (такая переменная создается и инициализируется один раз для всех экземпляров, сколько бы их не было).