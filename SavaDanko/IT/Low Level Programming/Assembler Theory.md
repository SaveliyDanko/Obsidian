## <mark style="background: #BBFABBA6;">Регистры</mark>
Регистры в электронных вычислительных машинах (ЭВМ) — это важные и высокоскоростные компоненты, расположенные в микропроцессоре, которые используются для хранения промежуточных данных при выполнении инструкций. Они представляют собой небольшие объемы памяти, оптимизированные для максимально быстрого доступа.

**Функции и особенности регистров в ЭВМ**
*Хранение операндов и результатов операций*
Регистры используются для хранения операндов (данных, с которыми производятся операции), промежуточных результатов и конечных результатов арифметических и логических операций, проводимых процессором.

*Хранение указателей*
Регистры часто используются для хранения специальных значений, таких как адреса в памяти (например, указатели на текущую позицию в программе или адрес возврата из подпрограммы).

*Управление и состояние процессора*
Некоторые регистры управляют функционированием процессора или содержат флаги, отображающие текущее состояние выполнения инструкций (например, флаг переполнения или флаг нулевого результата).

**Типы регистров**
*Регистры общего назначения*
Эти регистры можно использовать для различных функций, таких как хранение временных данных или переменных во время выполнения программы. В зависимости от архитектуры процессора, число таких регистров и способы их использования могут сильно различаться.

*Регистры специального назначения*
К этой категории относятся регистры, предназначенные для конкретных целей:
   - Регистр инструкций (Instruction Register, IR): хранит код текущей выполняемой инструкции.
   - Счетчик команд (Program Counter, PC): содержит адрес следующей инструкции, которую нужно выполнить.
   - Указатели стека (Stack Pointer): содержит адрес вершины стека в ОЗУ.
   - Регистры флагов (Status Registers): содержат биты состояния, которые указывают на определенное условие после выполнения операций (например, флаг переполнения).

*Регистры сегментов*
В архитектуре x86 эти регистры используются для деления памяти на сегменты для управления доступом и организации данных.

**Важность регистров**
Регистры важны для вычислительной эффективности по следующим причинам:
- Скорость доступа: Регистры являются самыми быстрыми доступными областями памяти.
- Уменьшение нагрузки на память: Использование регистров для промежуточного хранения данных уменьшает количество обращений к более медленной оперативной памяти.

## <mark style="background: #BBFABBA6;">Шины</mark> 
Шина в электронных вычислительных машинах (ЭВМ) представляет собой набор проводных электрических соединений, которые используются для передачи данных между различными компонентами системы. Шины являются критическими компонентами в архитектуре компьютера, поскольку они обеспечивают механизм для обмена информацией между центральным процессором (ЦПУ), оперативной памятью, устройствами хранения данных и другим периферийным оборудованием.

Основные виды шин:
1. Шина данных: Передаёт актуальные данные между компонентами. Широко используется для обмена данными между центральным процессором и ОЗУ.
2. Шина адреса: Передаёт адреса памяти, к которым система должна получить доступ, что позволяет ЦПУ указать, откуда читать или куда писать данные.
3. Шина управления: Передаёт команды управления и сигналы состояния между компонентами системы, например, сигналы чтения или записи.

Шины могут быть реализованы как параллельные (множество линий для передачи данных одновременно) или последовательные (данные передаются последовательно по одной или нескольким линиям).
##  <mark style="background: #BBFABBA6;">Вентили</mark> 
Термин "вентиль" в контексте ЭВМ обычно относится к логическим вентилям, которые являются основными строительными блоками для цифровой схемотехники. Логические вентили — это элементарные устройства, выполняющие базовые логические функции, такие как И (AND), ИЛИ (OR) и НЕ (NOT). Эти базовые операции можно комбинировать для создания более сложных функций и являются фундаментом для создания все более сложных цифровых устройств, включая процессоры и контроллеры.
 
Функции логических вентилей в ЭВМ:
- Исполнение базовых логических функций: Самая основная функция логических вентилей заключается в выполнении элементарных логических операций. Эти операции являются стандартными блоками для построения более сложных цифровых интегральных схем.
- Построение более сложных схем: Простые вентили могут быть объединены для формирования сложных многокомпонентных схем, которые выполняют более сложные логические задачи, необходимые для функционирования ЭВМ.

## <mark style="background: #BBFABBA6;">Тактовый генератор</mark> 
Тактовые генераторы в электронных вычислительных машинах (ЭВМ) — это устройства, генерирующие электрические сигналы с заданной частотой, которые используются для синхронизации работы различных компонентов системы. Эти тактовые сигналы являются крайне важными, поскольку они определяют скорость, с которой работает процессор и другие устройства в компьютере.

*Основная роль тактовых генераторов*
Основная функция тактового генератора — предоставление регулярного, периодического сигнала, который используется для организации и синхронизации последовательности операций в компьютере. Каждый такт (или импульс) сигнала позволяет процессору и другим компонентам системы выполнять следующий шаг в обработке данных.

*Как работают тактовые генераторы*
Тактовые генераторы обычно содержат кварцевый резонатор, который колеблется с особенно высокой стабильностью и точностью. Кварц в тактовом генераторе вибрирует каждый раз, когда через него проходит электрический ток, создавая стабильный и точный сигнал. Этот резонатор определяет базовую частоту, на которой будет функционировать вся система.

*Применение тактовых генераторов в ЭВМ*
1. Синхронизация работы процессора: Процессоры используют тактовые сигналы для контроля времени выполнения каждой инструкции. Каждый такт может представлять собой начало, продолжение или завершение определенной операции внутри ЦПУ.
2. Согласование операций между компонентами: Не только процессор, но и другие компоненты, такие как память, видеокарты и интерфейсы ввода-вывода, требуют тактовых сигналов для правильной синхронизации работы.
3. Определение производительности системы: Частота тактового генератора напрямую влияет на скорость работы процессора и системы в целом. Выше частота генератора — выше скорость обработки данных.

*Важность тактового генератора*
Качество и точность тактового генератора имеют прямое влияние на стабильность и производительность компьютерной системы. Ошибки в тактовых генераторах могут привести к сбоям в работе системы или к нестабильности, поскольку все компоненты системы зависят от получаемых ими синхронизирующих импульсов для выполнения своих функций.
## <mark style="background: #BBFABBA6;">Сумматор</mark> 
Сумматор в электронных вычислительных машинах (ЭВМ) — это функциональный элемент, предназначенный для выполнения арифметических операций сложения двоичных чисел. Это один из базовых компонентов арифметико-логического устройства (АЛУ) в процессоре, который отвечает за проведение всех арифметических операций.

**Типы сумматоров**
Сумматоры бывают нескольких типов, в зависимости от сложности задач, которые они выполняют:

1. Полусумматор (Half Adder)
   - Суммирует два однобитовых двоичных числа.
   - Производит два выхода: сумму и перенос.
   - Полусумматор не может обрабатывать перенос из предыдущего разряда, поэтому его применение ограничено простейшими задачами.

2. Полный сумматор (Full Adder)
   - Более сложная схема, способная суммировать три однобитовых числа (два операнда плюс перенос с предыдущего разряда).
   - Возвращает результат в виде суммы и переноса на следующий старший разряд.
   - Полные сумматоры легко масштабируются и могут быть соединены вместе для суммирования многоразрядных чисел.

3. Последовательный сумматор
   - Обрабатывает каждый разряд чисел поочерёдно, используя один полный сумматор и временно храня переносы во временной памяти (такие как триггеры).
   - Такт за тактом обрабатывает биты числа, что делает схему медленнее, но экономичнее по ресурсам.

4. Параллельный сумматор
   - Использует множество полных сумматоров для одновременной обработки всех разрядов числа.
   - Быстрее последовательного сумматора, так как обрабатывает все биты одновременно, но требует больше логических элементов для его реализации.

**Работа полного сумматора**
Основные компоненты полного сумматора включают в себя:
- Две входные шины (для двух слагаемых).
- Вход переноса (вход, который принимает перенос из предыдущего младшего разряда).
- Выход суммы (однобитовый, результат сложения трёх входных бит).
- Выход переноса (перенос в старший разряд для следующего более старшего бита).

**Пример работы полного сумматора**
Рассмотрим сумматор, который складывает числа 1101 (13 в десятичной системе) и 1001 (9 в десятичной системе):
- Сумматор обрабатывает каждую пару бит соответствующих разрядов двух чисел, начиная с младших разрядов, передавая перенос в следующий старший разряд.
- Результатом сложения будет четырехбитовое число 10110 (22 в десятичной системе), где последний бит является результатом переноса из самого старшего разряда.
## <mark style="background: #BBFABBA6;">RS тригер (reset set trigger)</mark>
RS-триггер (Reset-Set триггер) — это простейший тип секвенциальной логической схемы, используемый для хранения одного бита информации. Он имеет два входа, обозначенных обычно как S (Set — установить) и R (Reset — сбросить), и два выхода, Q и $(\overline{Q})$, где $(\overline{Q})$ является инвертированным значением Q. Состояние этих выходов изменяется в зависимости от входных сигналов.

В базовой конфигурации RS-триггер может быть построен на логических элементах "ИЛИ-НЕ" (NOR) или "И-НЕ" (NAND).

**Работа в базовой конфигурации на NOR:**
1. Состояние "Set" (Установка): если на вход S подается высокий уровень сигнала (1), а на вход R подается низкий (0), триггер устанавливается в состояние, где Q=1, а $(\overline{Q}=0)$.
2. Состояние "Reset" (Сброс): если на вход R подается 1, а на вход S подается 0, триггер сбрасывается в состояние, где Q=0, а $(\overline{Q}=1)$.

3. Состояние "Hold" (Хранение): если оба входа R и S в низком уровне (0), триггер сохраняет свое текущее состояние. Это состояние позволяет триггеру хранить один бит информации.

4. Запрещенное состояние: если на оба входа S и R подается высокий уровень (1), возникает конфликт, который приводит к неопределенному поведению триггера. В случае схемы на NOR-элементах, выходы Q и $(\overline{Q})$ оба будут в 0, что является нарушением основного правила триггера (Q всегда является инверсией $(\overline{Q}))$.


## <mark style="background: #BBFABBA6;">D-тригер</mark> 
D-триггер (Data или Delay) — это электронный элемент, используемый в цифровых схемах для хранения и передачи одного бита информации. Он имеет два основных входа и один выход:
1. D (Data) — вход данных.
2. CLK (Clock) — вход тактового сигнала, который контролирует момент считывания данных.

**Работа D-триггера**
Основной функцией D-триггера является захват значения, подаваемого на вход D, и его хранение до следующего сигнала на входе CLK. Иными словами, D-триггер копирует состояние входа D на свой выход при наступлении активного фронта сигнала часов (обычно это переход от низкого уровня к высокому, но могут использоваться и обратные схемы на отрицательном фронте). После того как входное значение прочитано, оно будет сохраняться до следующего активного тактового импульса.

**Устройство D-триггера**
Наиболее простая реализация D-триггера может включать в себя сочетание нескольких логических вентилей:
- RS-триггер обеспечивает основную функцию по хранению информации.
- Вентили AND и NOT используются для формирования условной логики, которая позволяет RS-триггеру принять и сохранить значение с D входа только при активном сигнале CLK.

**Выходы:**
- Q — основной выход, который показывает текущее сохраненное состояние.
- Q' (не Q или Q инвертированный) — инвертированный выход, который всегда противоположен Q.

**Принцип работы**
1. Загрузка данных: Когда на входе CLK происходит задний фронт импульса (или фронт, в зависимости от конкретной реализации триггера), данные с входа D копируются в триггер.
2. Хранение данных: После загрузки входного значения D триггер сохраняет это значение независимо от изменений на входе D до следующего импульса CLK.
## <mark style="background: #BBFABBA6;">x86 и x64 архитектура процессора</mark>
Архитектура процессора — это фундаментальный дизайн, который определяет, как процессор обрабатывает инструкции и взаимодействует с компьютерной памятью и другими компонентами системы. x86 и x64 являются двумя разными архитектурами процессора, каждая со своими характеристиками и возможностями.

**x86 Архитектура**
x86 обозначает семейство архитектур процессоров, которое начиналось с Intel 8086 в 1978 году. Эта архитектура имеет 32-битный дизайн, что влияет на её возможности работы с памятью и выполнения инструкций:

- Адресуемая память: x86 процессоры могут напрямую адресовать до 4 ГБ оперативной памяти.
- Комплект инструкций: x86 поддерживает большой набор инструкций, включая скалярные и векторные (например, SSE) операции.
- Совместимость: x86 процессоры могут запускать широкий спектр операционных систем и приложений, разработанных для 32-битных архитектур.

**x64 (или x86-64, AMD64) Архитектура**
x64, также известная как x86-64 или AMD64, представляет собой расширение архитектуры x86 для поддержки 64-битной обработки данных и адресации памяти. Это расширение было впервые представлено AMD, а затем подхвачено и другими производителями, включая Intel (под названием Intel 64):

- Адресуемая память: x64 архитектура расширяет предел адресации памяти до $2^{64}$ байт (около 18,4 эксабайт), что на практике обычно ограничивается аппаратным обеспечением и операционными системами существенно меньшей величиной, но всё же значительно превышает 4 ГБ.
- Комплект инструкций: x64 архитектура включает в себя все инструкции x86 и добавляет новые инструкции и регистры для 64-битной работы и повышения производительности.
- Совместимость: x64 процессоры могут выполнять как родные 64-битные, так и 32-битные x86 приложения, однако 64-битные операционные системы обычно требуются для полноценной работы с 64-битными приложениями.

**Основные отличия**
Основное отличие между x86 и x64 архитектурами процессоров заключается в их возможностях обработки данных и адресации памяти:

1. Адресация памяти: x64 может напрямую адресовать значительно больше памяти по сравнению с x86.
2. Производительность: x64 обычно предлагает лучшую производительность за счет использования дополнительных регистров и 64-битных инструкций, особенно для приложений, требующих обработки больших объемов данных.
3. Совместимость: x86 процессоры ограничены 32-битными приложениями, в то время как x64 процессоры могут запускать как 32-битные, так и 64-битные приложения.

## <mark style="background: #BBFABBA6;">Многопроцессорные системы</mark> 
Архитектура многопроцессорных электронно-вычислительных машин (ЭВМ) организована таким образом, чтобы несколько процессоров могли эффективно работать вместе, выполняя вычислительные задачи. Это позволяет значительно увеличить производительность системы за счет параллельной обработки данных. Рассмотрим ключевые аспекты многопроцессорной архитектуры:

1. Классификация многопроцессорных систем
Многопроцессорные системы обычно классифицируют по двум основным категориям:
- **Однородные системы**: Все процессоры идентичны и имеют равный доступ ко всем ресурсам.
- **Неоднородные системы**: Процессоры могут отличаться по мощности или функциональности, и некоторые могут иметь специализированные задачи.

2. Архитектура памяти
- **Системы с общей памятью (`SMP`, Symmetric Multiprocessing)**:
  - Все процессоры имеют доступ к общей глобальной памяти, что упрощает программирование, но может создавать узкие места из-за конфликтов доступа к памяти.
  
- **Системы с распределенной памятью**:
  - Каждый процессор имеет свою локальную память. Система может масштабироваться лучше, так как добавление процессоров с их собственными памятями уменьшает конкуренцию за память. Однако программирование таких систем сложнее из-за необходимости управления данными между разными памятями.
  
- **Гибридные системы (`NUMA`, Non-Uniform Memory Access)**:
  - Комбинируют элементы `SMP` и систем с распределенной памятью. Процессоры имеют доступ к локальной памяти быстрее, чем к памяти, расположенной у других процессоров.

3. Соединения
- **Шины**: Простая и стандартная технология для подключения нескольких процессоров, но может стать узким местом при большом количестве процессоров.
- **Переключаемые сети**: Используются для подключения большого количества процессоров с минимизацией задержек и конфликтов, что обычно встречается в высокопроизводительных вычислительных системах.

4. Когерентность кэша
- **Когерентность кэша**: Важна в системах с общей памятью, где каждый процессор имеет свой собственный кэш. Механизмы когерентности кэша обеспечивают, что все копии одного и того же блока данных в разных кэшах процессоров остаются согласованными.

5. Программное обеспечение
- **Параллельные операционные системы**: ОС, оптимизированные для работы на многопроцессорных системах, могут управлять распределением задач и синхронизацией между процессорами.

## <mark style="background: #BBFABBA6;">UMA, NUMA</mark>
**UMA (Uniform Memory Access)**
UMA — это архитектура симметричных многопроцессорных систем (`SMP`, Symmetric Multiprocessing), где каждый процессор имеет равный доступ ко всей памяти. Это значит, что время доступа к любому участку памяти одинаково для всех процессоров. В UMA:
- **Общая память**: Все процессоры делают запросы к единой общей памяти.
- **Равномерность доступа**: Независимо от того, где данные находятся в памяти, время доступа к этим данным одинаково для всех процессоров.
- **Простота дизайна**: Программирование для таких систем проще, так как разработчикам не нужно учитывать различия во времени доступа к разным частям памяти.

Основным недостатком UMA является то, что с увеличением числа процессоров возрастают конкуренция за доступ к памяти и задержки, что может стать узким местом в производительности системы.

**NUMA (Non-Uniform Memory Access)**
NUMA — это архитектура, в которой каждый процессор или группа процессоров имеет свою собственную локальную память, а доступ к памяти других процессоров возможен, но занимает больше времени. В NUMA:
- **Локальная и удалённая память**: Процессоры имеют быстрый доступ к своей локальной памяти и более медленный доступ к памяти, которая физически находится рядом с другими процессорами.
- **Неравномерность доступа**: Время доступа к памяти зависит от местоположения данных относительно процессора.
- **Масштабируемость**: Эта архитектура лучше масштабируется с увеличением числа процессоров, так как уменьшается конкуренция за доступ к памяти.

Программирование для NUMA более сложное, так как разработчики должны учитывать расположение памяти для оптимизации производительности, особенно в задачах, где важен интенсивный доступ к памяти.

## <mark style="background: #BBFABBA6;">CISC, RISC, VLIW</mark>
**CISC (Complex Instruction Set Computing)**
Архитектура CISC характеризуется сложным набором инструкций. В CISC процессорах каждая инструкция может выполнять несколько низкоуровневых операций (например, загрузку данных, математическую операцию и сохранение результатов) за один такт центрального процессора.

Особенности CISC:
- **Большой набор инструкций**: Инструкции могут быть очень сложными и выполнять обширные задачи.
- **Инструкции переменной длины**: Это означает, что инструкции могут занимать различное количество байтов в памяти.
- **Микропрограммное управление**: Большинство операций реализовано через микрокод, что упрощает реализацию сложных инструкций на уровне аппаратного обеспечения.

CISC процессоры были разработаны для минимизации количества инструкций на программу, что должно было облегчить написание программного обеспечения. Однако сложность инструкций приводит к тому, что их выполнение может занимать несколько тактов процессора.

**RISC (Reduced Instruction Set Computing)**
Архитектура RISC, в отличие от CISC, основана на идее упрощения набора инструкций, используемых процессором. Это упрощение позволяет каждой инструкции выполняться за один такт цикла процессора, что ускоряет выполнение программ.

**Особенности RISC:**
- **Ограниченный набор инструкций**: Инструкции просты и стандартизированы.
- **Инструкции фиксированной длины**: Упрощает декодирование и выполнение инструкций.
- **Использование регистров**: RISC процессоры часто используют большое количество регистров для ускорения доступа к данным.
- **Отсутствие микрокода**: Инструкции выполняются аппаратно, что делает их выполнение более быстрым.

RISC архитектуры эффективно используются в современных мобильных устройствах и встроенных системах, где важны энергоэффективность и простота обработки.

**VLIW (Very Long Instruction Word)**
Архитектура VLIW ориентирована на выполнение нескольких инструкций одновременно. Основная идея состоит в том, чтобы упаковать несколько операций в одно длинное инструкционное слово, которое процессор затем выполняет параллельно.

**Особенности VLIW:**
- **Длинные инструкционные слова**: Каждое слово может содержать несколько операций.
- **Параллельное выполнение**: Эффективность достигается за счет одновременного выполнения нескольких операций.
- **Зависимость от компилятора**: Компиляторы для VLIW должны уметь эффективно распределять инструкции для параллельного выполнения.

VLIW архитектуры часто используются в высокопроизводительных вычислительных системах, таких как цифровая обработка сигналов и мультимедийные приложения, где важна способность эффективно обрабатывать большие объемы данных параллельно.

## <mark style="background: #BBFABBA6;">Микропрограммы</mark>
Микропрограммный уровень в ЭВМ, также известный как уровень микрокода, занимает промежуточное положение между аппаратным обеспечением и программным управлением на более высоких уровнях. Этот уровень содержит набор базовых инструкций или микроинструкций, которые управляют низкоуровневым поведением аппаратных устройств, например, процессора.

**Основы микропрограммного уровня**
Микропрограммы работают на уровне управления процессором, напрямую взаимодействуя с его внутренними регистрами, шинами и другими элементами. Они определяют, как процессор должен интерпретировать и исполнить машинные инструкции, которые выше по уровню.

Каждая операция на уровне машинного кода может быть разложена на серию более мелких шагов, выполняемых микрокодом. Например, микрокод контролирует, как процессор должен выполнить операцию сложения, управляя релевантными аппаратными схемами для выполнения этой операции.

**Примеры функций микропрограммного уровня**
1. **Декодирование инструкций** - Преобразование инструкций, полученных из памяти, в набор операций, которые должны быть выполнены.
2. **Управление АЛУ** - Определение и контроль операций, которые выполняются в арифметико-логическом устройстве.
3. **Управление доступом к памяти** - Организация процессов чтения и записи в память.
4. **Управление состоянием регистров** - Контроль над регистрами процессора, их выбором и использованием в зависимости от выполняемой операции.

**Преимущества микропрограммного подхода**
1. **Гибкость** - Изменение функциональности процессора может быть достигнуто путём обновления микрокода, без необходимости изменения аппаратной архитектуры.
2. **Совместимость** - Микрокод можно использовать для эмуляции работы других процессоров или поддержки старых инструкций на новом оборудовании.
3. **Упрощение дизайна** - Микрокод позволяет процессорам иметь более простую и модульную архитектуру на физическом уровне, что упрощает разработку и поддержку.

## <mark style="background: #BBFABBA6;">ALU</mark>
Арифметико-логическое устройство (АЛУ) — это ключевой компонент центрального процессора (ЦП) электронно-вычислительной машины (ЭВМ), который отвечает за выполнение арифметических и логических операций над данными. АЛУ является центральной частью процессора, поскольку именно здесь происходят все основные вычисления.

**Структура АЛУ**
АЛУ состоит из следующих основных элементов:
1. **Регистры**:
   - **Регистры операндов** — временно хранят операнды, которые будут использоваться в операциях.
   - **Результатный регистр** — хранит результат операций, выполненных АЛУ.

2. **Блок операций**:
   - **Логические схемы** — выполняют базовые арифметические операции (сложение, вычитание, умножение и деление).
   - **Логические элементы** — выполняют логические операции (И, ИЛИ, НЕ, XOR и др.).

3. **Дешифратор операций**:
   - Распознает код операции, пришедший из управляющего устройства, и активирует соответствующие схемы в блоке операций для выполнения этой операции.

4. **Шины данных и управления**:
   - Обеспечивают передачу данных и управляющих сигналов между АЛУ, регистрами и другими компонентами процессора.

**Принципы работы АЛУ**
Работа АЛУ состоит из нескольких этапов:
1. **Загрузка операндов**
   - Операнды загружаются из регистров памяти в регистры операндов АЛУ.

2. **Дешифрация операции**:
   - Дешифратор операций получает код операции и определяет, какую операцию необходимо выполнить.

3. **Выполнение операции**:
   - Запускается соответствующая схема в блоке операций для выполнения арифметической или логической операции.

4. **Вывод результата**:
   - Полученный результат операции записывается обратно в результатный регистр или в память.
## <mark style="background: #BBFABBA6;">Дешифратор</mark> 
Дешифратор в ЭВМ (электронно-вычислительной машине) — это цифровое устройство или электронная схема, которая выполняет операцию обратную кодированию, то есть преобразует закодированный сигнал обратно в исходный вид или в другой заданный формат. В более узком и часто используемом контексте, дешифратор - это устройство, принимающее на вход кодированный сигнал (чаще всего в виде двоичного кода) и активирующее один из своих выходов в соответствии с входным сигналом. 

**Применение дешифраторов**
1. Выбор строки в матрице памяти: В системах памяти дешифраторы часто используются для выбора конкретной строки памяти для записи или чтения данных. Входной адрес разделен на две части: одна часть адреса используется дешифратором строк, а другая - дешифратором столбцов.

2. Разрешение устройств: В системах, где несколько устройств подключены к одной шине, дешифратор может использоваться для определения, какое устройство должно быть активировано для текущей операции ввода/вывода.

3. Дешифрующие таблицы правды: В логических схемах и устройствах на их основе дешифраторы используются для реализации специфических функций, соответствующих таблицам истинности, где на основании входных сигналов производится выбор конкретных действий или выходных состояний.

**Особенности**
- Простота интеграции: Дешифраторы могут быть очень простыми в реализации на логических элементах и легко встраиваются в более сложные системы управления.
- Фиксированная функция: Каждый дешифратор реализует фиксированную функцию преобразования из определенного набора входных комбинаций в определенный набор выходных сигналов.
- High Impedance State (высокоимпедансное состояние): Некоторые дешифраторы могут поддерживать третье состояние выхода, которое ни высокое (1), ни низкое (0), позволяя использовать их в более сложных схемах с несколькими устройствами, подключенными к одному и тому же выходу.
## <mark style="background: #BBFABBA6;">Ассинхронный обмен данных в ЭВМ</mark>
Асинхронный обмен данными в ЭВМ (электронных вычислительных машинах) — это процесс передачи данных между различными компонентами компьютера или между компьютерами, при котором отправитель и получатель не синхронизируются заранее для передачи данных. В отличие от синхронного обмена, где передача данных происходит по строго определённому графику или тактовым сигналам, асинхронный обмен позволяет передавать данные в любой момент времени, не дожидаясь специального сигнала или временного окна. 

**Особенности асинхронного обмена**
1. Независимость передачи данных от строгих временных рамок. Это означает, что компоненты системы могут общаться между собой, отправляя и получая данные в любое удобное для них время, без необходимости ждать определённого "слота" времени.

2. Использование стартовых и стоповых битов. В асинхронной передаче часто используются стартовые и стоповые биты для обозначения начала и конца передачи данных, что добавляет дополнительные издержки по объёму передаваемых данных, но делает процесс более гибким.

3. Буферизация данных. Для асинхронного обмена характерно использование буферов для временного хранения входящих или исходящих данных, пока получатель или отправитель не будут готовы к их обработке.

**Плюсы асинхронного обмена**
- Гибкость. Компоненты системы могут функционировать независимо, не ожидая друг друга, что позволяет избежать простоя.
- Эффективность использования ресурсов. Процессы могут работать параллельно, не блокируя друг друга, что повышает общую производительность системы.

**Минусы**
- Сложность дизайна и реализации. Управление асинхронными процессами и обеспечение корректного обмена данными могут быть значительно более сложными, по сравнению с синхронными системами.
- Возможность возникновения гонок данных и других проблем согласованности. Необходимы дополнительные механизмы для обеспечения целостности данных.

Асинхронный обмен данными находит применение во множестве областей, включая веб-разработку (асинхронные запросы к серверу), разработку программного обеспечения (асинхронное программирование), телекоммуникации и многие другие. Он позволяет создавать более отзывчивые и эффективно работающие системы, адаптированные к различным условиям и нагрузкам.
## <mark style="background: #BBFABBA6;">Синхронный обмен данных в ЭВМ</mark>
Синхронный обмен данными в ЭВМ (электронных вычислительных машинах) — это процесс передачи данных, при котором все действия происходят строго координированно по времени, в соответствии с определённым тактовым сигналом или временным графиком. Это означает, что отправка и приём данных происходят в установленные временные интервалы, и все участвующие в обмене компоненты синхронизированы между собой.

**Особенности синхронного обмена**
1. Тактовый сигнал. Передача данных происходит в строгом соответствии с тактовым сигналом, который служит референсным временным ритмом для всех компонентов системы. Этот сигнал определяет, когда данные должны быть отправлены или приняты.

2. Одновременная обработка. Данные передаются по множеству каналов одновременно или в рамках жёстко заданных временных интервалов, что позволяет добиться высокой степени параллелизма операций.

3. Предсказуемость и детерминированность. Так как передача данных синхронизирована, время обработки и передачи данных предсказуемо, что критически важно для некоторых приложений, требующих гарантированных временных параметров обмена.
   
4. Зависимость от скорости наимедленного компонента системы. Поскольку все компоненты системы работают в синхронном режиме, скорость обработки определяется скоростью наиболее медленного компонента.

**Плюсы синхронного обмена**
- Простота дизайна. Зачастую проще реализовать систему, где все компоненты работают в строгом соответствии друг с другом.
- Высокая надёжность. Строгая синхронизация минимизирует шансы потери данных или ошибок передачи.

**Минусы**
- Менее эффективное использование ресурсов. Если один из компонентов системы задерживает передачу, остальные должны ожидать его, прежде чем смогут продолжить работу, что может привести к простою.
- Трудности масштабирования. По мере роста системы поддерживать строгую синхронизацию между большим числом компонентов становится всё более сложным.

Синхронный обмен данными используется во многих сценариях, особенно там, где критически важна прогнозируемость и надёжность обмена, например, во встроенных системах, реальном времени, и в системах управления производственными процессами.

## <mark style="background: #BBFABBA6;">Представление символьных и строковых данных в ЭВМ</mark>
В ЭВМ символьные и строковые данные представляются при помощи кодировок, которые позволяют отображать символы в виде числовых значений, понятных компьютеру. Ниже представлены основные способы и форматы представления этих данных:

**ASCII (American Standard Code for Information Interchange)**
- ASCII — это один из первых стандартов кодирования символов, используемый для представления текста в компьютерах и других устройствах, основанных на тексте.
- Он включает в себя 128 символов (0-127), которые состоят из английского алфавита, цифр, управляющих кодов (например, переноса строки) и символов пунктуации.
- Каждый символ кодируется 7-битным числом, что позволяет использовать стандарт в 8-битной архитектуре, оставляя один бит для других целей.

**Расширенные кодировки ASCII**
- Существуют расширенные варианты ASCII, такие как **ISO-8859** и **Windows-1251**, которые используют дополнительный 8-й бит для представления дополнительных символов, включая символы из других языков (например, кириллица, арабские и ивритские буквы) и специальные графические символы.
- Эти расширения увеличивают количество возможных символов до 256.

**Unicode**
- Unicode — это универсальная система кодирования символов, предназначенная для представления и обработки текста, написанного любым из живых языков мира.
- Она поддерживает более миллиона символов, включая буквенно-цифровые символы, идеограммы (как в китайском языке), эмодзи и множество других.
- Существует несколько форматов представления Unicode, включая **UTF-8**, **UTF-16** и **UTF-32**.
    - UTF-8 — это переменная длина кодировки (от 1 до 4 байт на символ), позволяющая эффективно кодировать текст на латинице и обеспечивающая совместимость с ASCII.
    - UTF-16 использует 2 или 4 байта для представления символов и широко используется в таких системах, как Windows и Java.
    - UTF-32 требует 4 байта на символ, обеспечивая тем самым прямой доступ к каждому символу Unicode, но менее эффективна в плане использования памяти по сравнению с UTF-8 и UTF-16.

**Представление строк**
Строки представляют собой последовательности символов. В памяти ЭВМ строки могут храниться различными способами, в зависимости от используемого языка программирования и стандарта кодирования:

- С нулём в конце (null-terminated strings) — строка представляется как последовательность символов, за которой следует специальный нулевой символ $(0)$, указывающий на конец строки. Этот подход используется в языке программирования C.
- С указанием длины — строка может быть представлена структурой, содержащей поле для длины строки и данные строки. Такой способ используется, например, в языках Pascal и более высокоуровневых языках, как Python, Java, и .NET языках.

Оба эти подхода позволяют софту обрабатывать строковые данные, выполняя различные операции, такие как соединение строк, поиск подстроки, сравнение строк и другое.

## <mark style="background: #BBFABBA6;">Инициация обмена данными </mark>
Инициация обмена данными в ЭВМ (электронно-вычислительной машине) — это процесс, при котором устанавливается начало передачи данных между различными компонентами компьютера, например, между процессором и оперативной памятью, жёстким диском, периферийными устройствами или между отдельными компьютерами в сети. Этот процесс может быть как программно, так и аппаратно инициирован в зависимости от архитектуры системы и специфики задачи.

**Аппаратная инициация**
Аппаратная инициация включает в себя использование специализированных сигналов управления для начала передачи данных. Например, в архитектуре компьютера может присутствовать специальная линия запроса прерывания (IRQ), через которую периферийное устройство может сигнализировать процессору о необходимости обмена данными. В ответ на это процессор может инициировать передачу данных, используя протоколы и интерфейсы ввода/вывода (например, SPI, I2C, USB).

**Программная инициация**
Программная инициация происходит на уровне программного обеспечения и означает, что процесс обмена данными начинается с выполнения определённых инструкций или вызовов функций в программе. Например, операционная система может отправить команду на чтение данных с жёсткого диска, используя соответствующий системный вызов или API драйвера устройства.

**Примеры инициации обмена данными**
- DMA (Direct Memory Access): Это метод, при котором данные могут быть переданы между памятью и устройством ввода/вывода без непосредственного участия центрального процессора. Инициация DMA-передачи может происходить как со стороны устройств, так и по команде процессора.
- Прерывания: Периферийное устройство может сгенерировать прерывание для процессора, чтобы сообщить о готовности к обмену данными или о наличии новых данных для обработки.
- Поллинг (опрос): Программа или операционная система регулярно проверяет статус устройства (например, ввода/вывода), чтобы определить, готово ли оно к обмену данными.


## <mark style="background: #BBFABBA6;">Вектор прерываний</mark>
Вектор запроса на прерывание в ЭВМ (электронно-вычислительной машине) — это уникальный идентификатор, который используется для определения источника прерывания и соответствующей реакции системы на это прерывание. В общем смысле, это может быть понято как адрес или указатель на обработчик прерывания, который должен быть выполнен в ответ на конкретное прерывание.

Прерывание — это сигнал процессору от аппаратного или программного источника о необходимости временно прекратить выполнение текущих задач и переключиться на обработку события, вызвавшего прерывание. Прерывания используются для обработки событий в реальном времени, таких как ввод/вывод данных, ошибки или специфические условия в программе.


**Как работает система векторов прерываний:**
1. Сигнал Прерывания: Когда устройство или программа генерирует сигнал прерывания, контроллер прерываний определяет приоритет запроса и решает, обслуживать его немедленно или отложить.

2. Определение Вектора Прерывания: Для каждого типа прерывания предусмотрен свой уникальный вектор (идентификатор или адрес). Этот вектор указывает на место (адрес) в памяти, где находится начало соответствующей процедуры обработки прерывания.

3. Передача Управления: Процессор использует этот вектор для перехода к обработчику прерывания, который содержит код, специфичный для данного типа прерывания. Таким образом, система может адекватно реагировать на различные события.

4. Завершение Прерывания: После выполнения обработчика прерывания система возвращает контроль текущей выполняемой программе, обычно возобновляя выполнение с того места, где оно было прервано.
## <mark style="background: #BBFABBA6;">Линия запроса прерывания IRQ</mark> 
Линия запроса прерывания (IRQ, Interrupt Request Line) в ЭВМ (электронно-вычислительной машине) — это сигнальная линия или канал связи, по которому периферийное устройство может уведомлять центральный процессор (ЦПУ) о событии, требующем внимания. Система прерываний позволяет процессору реагировать на различные аппаратные и программные события, не занимаясь бесконечным опросом состояния всех устройств, что повышает эффективность работы системы.

Когда периферийное устройство генерирует запрос на прерывание по соответствующей линии IRQ, это сигнализирует процессору о необходимости временной остановки текущей задачи и выполнения специальной функции обработчика прерывания, ассоциированной с данным событием. После обработки прерывания процессор может либо вернуться к прерванной задаче, либо переключиться на выполнение других задач в зависимости от приоритетов и политики планирования задач операционной системы.

**Использование IRQ**
Линии запросов прерывания используются для множества целей, таких как:
- Уведомление о завершении передачи данных (например, когда буфер устройства ввода/вывода заполнен и данные готовы к обработке).
- Сигнализация о возникновении ошибки или исключительной ситуации (например, переполнение буфера).
- Уведомление о наступлении внешних событий (например, нажатие клавиши на клавиатуре).

**Назначение и конфликты IRQ**
В компьютере каждой линии IRQ обычно назначается уникальный номер. Однако в реальности количество доступных линий IRQ ограничено аппаратными возможностями системы, что может приводить к конфликтам, когда несколько устройств пытаются использовать одну и ту же линию IRQ. Современные компьютерные системы и операционные системы предоставляют возможности для управления IRQ, позволяя корректировать и изменять назначения IRQ для разрешения подобных конфликтов.

В прошлом, когда компьютеры чаще всего использовались в конфигурации с общей шиной и множеством подключаемых к ней карт расширения, конфликты IRQ были довольно распространённой проблемой. В современных же системах, особенно с появлением технологий, таких как PCI Express, которые поддерживают механизмы динамического назначения ресурсов, включая IRQ, проблема конфликтов IRQ стала намного менее актуальной.
## <mark style="background: #BBFABBA6;">Программно-управляемый обмен данными</mark>
Программно управляемый обмен данными в ЭВМ (Электронно-Вычислительной Машине) — это процесс передачи данных между различными компонентами системы (процессором, памятью, устройствами ввода-вывода и пр.), который полностью контролируется программным обеспечением. В отличие от аппаратно реализованных методов передачи данных, таких как прямой доступ к памяти (DMA), в этом случае весь процесс обмена, включая инициацию передачи, контроль за ее выполнением и обработку ошибок, осуществляется за счет процессорного времени под управлением программы.

**Ключевые аспекты программно-управляемого обмена данными:**
- Управление процессором: Все действия по организации передачи данных осуществляются за счет системного процессора посредством выполнения соответствующих инструкций программы.
  
- Поллинг устройств: Один из распространенных методов — периодический опрос состояния устройства или статуса операции передачи данных с помощью программных циклов. Если устройство готово к обмену или требует внимания, процессор выполняет соответствующие действия (например, чтение данных из буфера устройства).

- Программное прерывание: Также может быть настроено программируемое прерывание, когда устройство сигнализирует о своем состоянии через определенный сигнал прерывания. В этом случае программа-обработчик прерывания занимается обслуживанием события.

**Преимущества:**
- Гибкость: Программный контроль позволяет легко изменять логику работы без необходимости изменения аппаратной конфигурации.
  
- Универсальность: Может быть реализован на любом оборудовании, способном исполнять программный код.

**Недостатки:**
- Низкая эффективность: Процессор тратит ценные такты на управление передачей данных, что снижает его производительность для основных вычислительных задач.
  
- Задержки: В отличие от аппаратных методов передачи данных, таких как DMA, время обмена данными может быть значительно больше из-за программного управления и необходимости выполнения дополнительных инструкций.

## <mark style="background: #BBFABBA6;">Direct Memory Access (DMA)</mark>
Direct Memory Access (DMA) — это возможность, позволяющая устройствам ввода/вывода (I/O devices) обмениваться данными непосредственно с памятью компьютера, минуя центральный процессор (ЦПУ). Этот механизм значительно повышает скорость передачи данных и эффективность работы системы, так как освобождает ЦПУ от необходимости участвовать в каждой операции передачи данных, что позволяет ему одновременно выполнять другие задачи.

**Как работает DMA**
1. Инициация: Процесс начинается, когда устройство запросит доступ к шине для проведения операции DMA. Этот запрос может быть сделан, например, когда устройству необходимо передать блок данных в память или прочитать его из памяти.

2. Предоставление доступа: Контроллер DMA выдает разрешение на доступ к шине после того, как текущая операция шины будет завершена. В это время ЦПУ может быть временно отключено от шины данных и адреса, чтобы предотвратить конфликты.

3. Передача данных: Контроллер DMA управляет передачей данных, направляя их или из памяти, или в память от соответствующего устройства. Он также следит за количеством переданных данных и контролирует адреса в памяти, куда или откуда должны быть переданы данные.

4. Завершение операции: По завершении передачи данных контроллер DMA отправляет сигнал ЦПУ о завершении операции. В этот момент ЦПУ может возобновить непосредственный контроль над шиной.

**Применение DMA**
DMA широко используется для повышения производительности и эффективности компьютеров, особенно в операциях, требующих быстрой и интенсивной обработки больших объемов данных, таких как:

- Передача данных между жестким диском и оперативной памятью.
- Видеообработка и передача изображений в видеопамять.
- Сетевые операции, включая обмен данными между сетевыми картами и системной памятью.

**Преимущества DMA**
- Эффективность: Освобождает ЦПУ для выполнения других задач, повышая общую производительность системы.
- Скорость: Позволяет обмениваться данными с высокой скоростью, что критически важно для мультимедийных приложений и приложений в реальном времени.
- Автономность: Устройства могут осуществлять обмен данными без непрерывного участия ЦПУ, что упрощает программное управление операциями ввода/вывода.

## <mark style="background: #BBFABBA6;">Контроллер внешнего устройства </mark>
Контроллер внешнего устройства в ЭВМ — это специализированная электронная схема или модуль, предназначенный для управления взаимодействием компьютера с одним или несколькими внешними устройствами. Он служит своеобразным посредником между процессором (или центральным процессорным устройством, ЦПУ) и внешними устройствами, такими как жесткие диски, оптические приводы, клавиатуры, мыши, принтеры и др.

**Ключевые задачи контроллера внешних устройств включают в себя:**
1. Передача данных: Контроллер обеспечивает передачу данных между внешним устройством и системной памятью или ЦПУ. Он преобразует данные из параллельной формы в последовательную для передачи по сети или наоборот, в зависимости от требований.
2. Преобразование сигналов: Контроллер может преобразовывать сигналы, получаемые от ЦПУ, в формат, который может быть интерпретирован внешним устройством. Такое преобразование включает в себя изменение напряжения, кодирование данных и т.д.
3. Управление командами: Контроллер внешнего устройства интерпретирует команды, поступающие от ЦПУ, и преобразует их в действия, которые необходимо выполнить внешнему устройству. Это может включать в себя чтение или запись данных, запуск или остановку устройства.
4. Буферизация: Контроллер может временно хранить данные в буфере для выравнивания скорости передачи данных между быстрым ЦПУ или памятью и относительно медленным внешним устройством.
5. Управление ошибками: Контроллер обнаруживает ошибки во время передачи данных и, при возможности, исправляет их. Также он может сообщать об ошибках операционной системе или прямо пользователю.
6. Синхронизация: Он координирует время передачи данных между внешним устройством и компьютером, чтобы обеспечить корректное взаимодействие между всеми компонентами системы.

## <mark style="background: #BBFABBA6;">Драйвер</mark> 
Драйвер в ЭВМ (электронно-вычислительной машине), также известный как драйвер устройства или программный драйвер, — это специальный тип программного обеспечения, который позволяет операционной системе и другому программному обеспечению взаимодействовать с аппаратным обеспечением компьютера. Драйверы служат своего рода "переводчиками" между программным и аппаратным обеспечением, обеспечивая корректное функционирование различных компонентов системы, таких как видеокарты, принтеры, сетевые адаптеры и так далее.


**Основные функции драйверов:**
1. Инициализация устройства: Драйверы загружаются при загрузке системы или при подключении устройства и выполняют начальную настройку устройства, готовя его к работе с операционной системой.

2. Взаимодействие ОС с устройством: Драйверы предоставляют интерфейс, который операционная система использует для отправки команд на устройства и получения данных от них. Это позволяет программам использовать стандартные функции ОС для работы с различным аппаратным обеспечением без необходимости знать тонкости работы конкретного устройства.

3. Обработка прерываний: Многие устройства функционируют, отправляя прерывания процессору, чтобы сообщить о событиях, таких как завершение задания или необходимость обработки данных. Драйвер устройства обрабатывает эти прерывания и выполняет соответствующие действия, такие как перенос данных в память.

4. Прямой доступ к оборудованию: Драйверы могут напрямую общаться с аппаратными средствами управления и выполнения, предоставляя тонкую настройку работы устройства или доступ к специфическим функциям.

**Типы драйверов:**
- Устройство ядра: Интегрируются в ядро операционной системы и работают на очень низком уровне, обеспечивая максимальную производительность и доступ к критичным функциям системы.
- Драйверы в пользовательском пространстве: Хотя они обеспечивают меньшую скорость по сравнению с драйверами устройств ядра, они являются более безопасными, так как не имеют прямого доступа к критически важной памяти и системным процессам.
- Драйверы виртуализации: Позволяют устройствам виртуальных машин взаимодействовать с оборудованием хост-системы.

## <mark style="background: #BBFABBA6;">Ядро операционной системы</mark> 
Ядро операционной системы (OS) — это центральная часть операционной системы, которая управляет ресурсами компьютера и взаимодействует напрямую с аппаратным обеспечением. Ядро является фундаментальным компонентом, который обеспечивает базовые сервисы для всех других частей системы и программ, выполняемых на компьютере. Вот основные аспекты и функции ядра операционной системы:

**Управление ресурсами**
Ядро управляет доступом к аппаратным ресурсам, таким как процессор (CPU), память и устройства ввода-вывода. Оно регулирует, как программы получают доступ к этим ресурсам, обеспечивая корректное и эффективное использование аппаратуры.

**Планирование процессов**
Ядро отвечает за планирование процессов и потоков, определяя, какой процесс или поток должен использовать процессор и когда. Это критически важно для обеспечения отзывчивости и эффективности работы многозадачной системы.

**Управление памятью**
Ядро контролирует распределение и управление памятью между процессами. Оно обеспечивает механизмы для выделения, освобождения и защиты памяти, а также управляет виртуальной памятью для расширения доступной физической памяти с помощью дискового пространства.

**Обработка прерываний**
Ядро реагирует на прерывания от аппаратного обеспечения, которые могут сигнализировать о различных событиях, таких как завершение ввода данных с клавиатуры или поступление данных от сетевого адаптера. Обработка прерываний позволяет системе быть отзывчивой и взаимодействовать с аппаратным обеспечением в реальном времени.

**Взаимодействие с устройствами**
Ядро управляет драйверами устройств, которые представляют собой специальное программное обеспечение, позволяющее операционной системе взаимодействовать с аппаратным обеспечением. Драйверы предоставляют ядру стандартизированный способ выполнения операций с устройствами.

**Обеспечение безопасности**
Ядро также отвечает за безопасность системы, контролируя доступ к ресурсам и данным. Оно обеспечивает изоляцию и разделение между процессами, предотвращая несанкционированный доступ и возможные ошибки в одной программе, которые могут повлиять на другие процессы.

**Типы ядер**
Существуют различные архитектуры ядер, включая:
- Монолитное ядро: все необходимые сервисы операционной системы и драйверы находятся в одном большом блоке программного обеспечения.
- Микроядро: функциональность ядра минимизирована; большинство сервисов работают в пользовательском пространстве, что улучшает безопасность и стабильность.
- Гибридное ядро: комбинация монолитного и микроядра, предлагающая баланс между производительностью и модульностью.

Каждая из этих архитектур имеет свои преимущества и недостатки, и выбор конкретной зависит от целей и требований к операционной системе.
## <mark style="background: #BBFABBA6;">Позиционно-независимый код</mark> 
**Позиционно-независимый код (Position-Independent Code, PIC)** — это тип машинного кода, который исполняется корректно, независимо от его физического адреса в памяти. Это означает, что такой код может быть загружен в любое место в адресном пространстве памяти без необходимости изменения его базового кода или данных. Создание позиционно-независимого кода критически важно для систем, поддерживающих динамическую загрузку библиотек и исполняемых файлов, например, в операционных системах современных компьютеров.

**Зачем нужен позиционно-независимый код**
1. **Динамически загружаемые библиотеки (DLL на Windows или .so в Unix/Linux):** Позиционно-независимый код позволяет операционной системе загружать библиотеки в произвольные области памяти без дополнительных издержек на перемещение или модификацию кода. Это увеличивает эффективность использования памяти и уменьшает время загрузки.

2. **Безопасность:** Использование PIC увеличивает безопасность системы, так как это облегчает реализацию техник таких, как ASLR (Address Space Layout Randomization), которая повышает защиту от атак, направленных на исполнение произвольного кода.

**Как реализуется PIC**
1. **Относительные адреса:** Вместо использования абсолютных адресов для доступа к данным или вызова функций, PIC использует относительные адреса (смещения относительно текущего положения инструкции). Это позволяет коду "знать" своё положение и корректно ссылаться на данные и функции, где бы он ни находился.

2. **Глобальная таблица оффсетов (GOT) и таблица процедурных ссылок (PLT):** В системах на базе Unix и Linux для поддержки динамических вызовов функций и доступа к данным используются специальные таблицы. GOT хранит адреса данных, а PLT используется для разрешения адресов функций во время выполнения.

3. **Использование регистра базы:** Некоторые архитектуры используют специальный регистр, который всегда содержит адрес, относительно которого выполняются все операции доступа к данным. Это позволяет коду быть независимым от своего фактического местоположения в памяти.
## <mark style="background: #BBFABBA6;">Little Endian & Big Endian</mark> 
Little endian и big endian — это термины, используемые для описания порядка байтов при хранении или передаче многобайтовых данных (например, чисел) в компьютерных системах. Различие между ними заключается в порядке, в котором байты числа размещаются в памяти компьютера или передаются по сети.

 **Little Endian**
В системах с little endian порядком ("младшим байтом вперёд") младший байт (байт с наименьшим значением) числа размещается в памяти по меньшему адресу, а старший байт — по большему. Это означает, что байты числа записываются в обратном порядке, начиная с младшего.

Например, число 0x12345678 в 32-битной системе с little endian порядком будет храниться в памяти следующим образом (адреса идут слева направо): 78 56 34 12.

**Big Endian**
В системах с big endian порядком ("старшим байтом вперёд") старший байт числа размещается в памяти по меньшему адресу, а младший байт — по большему. Это означает, что байты числа записываются в том же порядке, в котором они представлены в числе.

Применимо к тому же числу 0x12345678, в 32-битной системе с big endian порядком оно будет храниться в памяти следующим образом: 12 34 56 78.

**Значимость**
Выбор между little endian и big endian важен при разработке аппаратного обеспечения, сетевых протоколов и программного обеспечения, особенно при работе с различными архитектурами и при передаче данных между системами. Несоответствие порядка байтов может привести к неправильной интерпретации числовых данных, что потребует применения преобразований для корректировки порядка байтов.

Порядок байтов little endian используется во многих современных процессорных архитектурах, включая x86 от Intel и AMD. Big endian порядок традиционно использовался в сетевых протоколах (например, в протоколах на основе стека TCP/IP) и в некоторых архитектурах процессоров.
## <mark style="background: #BBFABBA6;">Stack in x64 architecture</mark>
**Работа стека в процессорах с архитектурой x64:**

1. Определение стека: В контексте вычислительной техники стек – это тип структуры данных, работающей по принципу "последним пришёл – первым вышел" (LIFO, Last In First Out). Стек используется для хранения временных данных, таких как адреса возврата из подпрограмм, локальные переменные и сохранённые значения регистров.

2. Расположение и направление роста: В архитектуре x64 стек растёт в обратном направлении, т.е. в сторону уменьшения адресов. Это значит, что при "помещении" (push) элемента на стек его адрес будет меньше, чем адрес элемента, который был помещён на стек до него. При "извлечении" (pop) элемент из стека происходит обратная операция.

3. Использование регистра RSP: Основным регистром, используемым для управления стеком, является RSP (Stack Pointer). RSP указывает на вершину стека. При операции push адрес, хранящийся в RSP, уменьшается на размер помещаемых в стек данных (обычно на 8 байт, так как это размер слова в архитектуре x64), а после этого новые данные записываются по этому адресу. При операции pop данные считываются с текущего адреса, на который указывает RSP, после чего значение RSP увеличивается, освобождая место в стеке.

4. Выравнивание стека: Для обеспечения наилучшей производительности в архитектуре x64 стек должен быть выровнен по границе 16 байт. Это требование к выравниванию поддерживается перед вызовом функций: перед тем, как вызвать функцию, нужно убедиться, что стек выровнен должным образом, чтобы все доступы к стеку были оптимизированы.

5. Использование для вызова функций: При вызове функций аргументы могут передаваться через регистры или через стек, в зависимости от количества аргументов и их типов. Адрес возврата (адрес следующей инструкции после вызова функции) также сохраняется на стеке, что позволяет программе продолжить выполнение с точки, следующей за вызовом функции, после её завершения.

6. Обработка исключений и прерываний: Стек используется в процессах обработки исключений и прерываний для сохранения состояния процессора до начала обработки исключения или прерывания. Затем, после обработки, можно восстановить состояние и продолжить выполнение программы с того места, где оно было прервано.
## <mark style="background: #BBFABBA6;">STACK</mark> 
Работа стека в ассемблере является фундаментальной концепцией в программировании на низком уровне. Стек — это структура данных, работающая по принципу последним пришёл — первым ушёл (LIFO, Last In First Out). В контексте ассемблера стек часто используется для вызова функций, хранения временных данных, передачи параметров и сохранения контекста при прерываниях или вызовах подпрограмм.

**Основные операции со стеком в ассемблере:**
1. PUSH - помещает элемент на вершину стека. Это уменьшает указатель стека на размер элемента (так как в большинстве архитектур стек растёт в обратном направлении в памяти от больших адресов к меньшим).

2. POP - удаляет элемент с вершины стека и возвращает его значение. Это увеличивает указатель стека.

В ассемблере различных архитектур существуют свои определения и команды для работы со стеком. Например, в ассемблере x86:
- Для добавления значения в стек используется команда PUSH, а для его извлечения - POP.
- Указатель стека управляется регистром ESP в 32-битных операционных системах и регистром RSP в 64-битных.

**Рассмотрим базовый пример:**
```asm
PUSH EAX ; помещает значение регистра EAX на вершину стека
CALL SomeFunction ; вызывает функцию, в процессе чего адрес возврата также помещается на стек
POP EBX ; извлекает верхнее значение стека (ранее помещенное значение EAX) в регистр EBX
```

При вызове функции или подпрограммы адрес возврата (адрес следующей инструкции) также сохраняется на стеке. Это позволяет, после выполнения функции, вернуться к точке вызова. После выполнения функции значения параметров, адрес возврата и локальные переменные можно извлечь из стека, чтобы восстановить контекст выполнения.


## <mark style="background: #BBFABBA6;">Daemon</mark> 
**Демоны в операционных системах**
В контексте операционных систем демон (daemon) — это фоновый процесс, который выполняет системные задачи или обслуживает запросы от других процессов. Демоны обычно запускаются при загрузке системы и работают до её выключения. Они часто выполняют задачи, такие как управление сетевыми соединениями, обслуживание очередей задач, управление принтерами и т. д.

**Примеры демонов в Unix/Linux:**
- `httpd`: Веб-сервер Apache HTTP Server.
- `sshd`: Демон `OpenSSH`, который обслуживает SSH соединения.
- `cron`: Демон планировщика задач, который выполняет запланированные задачи.
- `syslogd: Демон для системного логирования.

**Характеристики демонов**
1. Фоновый процесс: Демоны работают в фоновом режиме и не требуют взаимодействия с пользователем.
2. Автоматический запуск: Демоны часто запускаются автоматически при загрузке системы и работают непрерывно.
3. Отсутствие терминала: Демоны обычно отсоединены от терминала и не имеют пользовательского интерфейса.
4. Обслуживание системных задач: Демоны выполняют различные системные задачи и обслуживают запросы от других процессов или сетевых клиентов.

