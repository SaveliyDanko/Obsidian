The **`let`** declaration declares re-assignable, block-scoped local variables, optionally initializing each to a value.
```js
let x = 1;

if (x === 1) {
  let x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 1
```


###### **Область видимости `let`**
Область видимости переменной, объявленной с помощью `let`, определяется ближайшей фигурной скобкой, в которой находится объявление. Это может быть:
- Блочный оператор (`{ ... }`)
- `switch`-оператор
- `try...catch`-блок
- Тело любого из операторов `for`, если `let` используется в заголовке
- Тело функции
- Блок статической инициализации (внутри классов)
    
Если ни один из вышеперечисленных вариантов не применим:
- В модульном режиме — переменная существует в пределах текущего модуля
- В скриптовом режиме — в пределах глобальной области видимости

###### **Отличия `let` от `var`**
В сравнении с `var`, объявления через `let` обладают следующими характеристиками:
1. `let` имеет блочную область видимости — действует не только внутри функций, но и внутри блоков.
2. Объявленные через `let` переменные недоступны до момента их инициализации, даже внутри их области видимости. Это известно как временная мёртвая зона (TDZ — temporal dead zone). В этом смысле `let` воспринимается как неподнимаемый (non-hoisted).
3. Переменные, объявленные через `let`, не добавляются как свойства к глобальному объекту `globalThis`, даже если они находятся на верхнем уровне скрипта.
4. `let` не может быть повторно объявлен в той же области видимости.
5. `let` инициирует объявление (declaration), а не выражение (statement). Это означает, что одинокая `let`-декларация не может выступать в роли единственного выражения внутри блока.
Пример ошибки:
```js
if (true) let a = 1;
// SyntaxError: Лексическое объявление не может находиться в контексте одиночного выражения
```

###### **Дополнительные замечания**
- Хотя в нестрогом режиме (`non-strict mode`) допустимо использовать `let` как имя переменной (например, `var let = 5`), это категорически не рекомендуется, так как может привести к синтаксическим неоднозначностям и труднообнаружимым ошибкам.
- Большинство руководств по стилю (включая [MDN](https://developer.mozilla.org/)) рекомендуют использовать `const` вместо `let` всякий раз, когда значение переменной не должно меняться. Это явно указывает на намерение разработчика: переменная должна быть неизменной.  
    `let` же остаётся предпочтительным выбором для изменяемых объектов — например, массивов или объектов, которые будут мутироваться.
    
###### Binding list (`let a = 1, b = a + 1`)
Список, следующий за ключевым словом `let`, называется binding list (список привязки). Он:
- Разделяется запятыми (но не является оператором запятой)
- Использует знак `=` в качестве инициализатора, а не оператора присваивания
Это позволяет переменным, объявленным позже, ссылаться на переменные, объявленные ранее в этом же списке:
```js
let x = 1, y = x + 2;
console.log(y); // 3
```


###### **Временная мёртвая зона (Temporal Dead Zone, TDZ)**
Переменная, объявленная с помощью `let`, `const` или `class`, считается находящейся во "временной мёртвой зоне" (TDZ) — с момента начала блока до момента, когда выполнение кода достигает места её объявления и инициализации.

Пока переменная находится в TDZ:
- Она ещё не инициализирована
- Любая попытка обратиться к ней приведёт к `ReferenceError`.
    
Переменная будет инициализирована значением:
- при достижении строки объявления во время исполнения;
- если значение не задано явно — оно будет `undefined`.

Это поведение отличается от `var`, который при обращении до объявления возвращает `undefined`, а не выбрасывает ошибку.

Пример:
```js
{
  // TDZ начинается с начала области видимости
  console.log(bar); // "undefined"
  console.log(foo); // ReferenceError: Невозможно обратиться к 'foo' до инициализации
  var bar = 1;
  let foo = 2; // Конец TDZ для foo
}
```