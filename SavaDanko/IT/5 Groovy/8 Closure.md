###### **Closure**
Определение замыкания в Groovy имеет следующий синтаксис:
```groovy
{ [параметрыЗамыкания -> ] инструкции }
```
- `[параметрыЗамыкания -> ]` — необязательный список параметров, разделённых запятыми. Параметры могут быть типизированными или нетипизированными.
- инструкции — одна или несколько инструкций Groovy.
Если указан список параметров, необходимо использовать символ `->` для отделения параметров от тела замыкания.

###### **Примеры корректных определений замыканий:**
```groovy
{ item++ } 
```
> Замыкание, ссылающееся на переменную `item` из внешнего контекста.

```groovy
{ -> item++ }
```
> Явное разделение параметров и тела с помощью `->`. Здесь нет параметров.

```groovy
{ println it }
```
> Замыкание с неявным параметром `it` — по умолчанию используется, если явно не указаны параметры.

```groovy
{ it -> println it }
```
> То же, что выше, но с явным указанием параметра `it`.

```groovy
{ name -> println name }
```
> Лучше давать параметрам осмысленные имена, особенно если `it` становится неочевидным.

```groovy
{ String x, int y ->
    println "hey ${x} the value is ${y}"
}
```
> Замыкание с типизированными параметрами `x` и `y`.

```groovy
{ reader ->
    def line = reader.readLine()
    line.trim()
}
```
> Замыкание с несколькими инструкциями внутри тела.

###### **Замыкания как объекты**
В Groovy замыкание — это экземпляр класса `groovy.lang.Closure`. Это означает, что замыкание можно присваивать переменной или полю, как и любой другой объект, несмотря на то, что по сути это блок кода.

Примеры:
```groovy
def listener = { e -> println "Clicked on $e.source" }      
assert listener instanceof Closure
```
> Замыкание `listener` присваивается переменной и является экземпляром `Closure`.

```groovy
Closure callback = { println 'Done!' }
```
> Если не используется `def` или `var`, можно явно указать тип — `Closure`.

```groovy
Closure<Boolean> isTextFile = {
    File it -> it.name.endsWith('.txt')
}
```
> Можно также указать обобщённый тип (`Closure<Boolean>`), чтобы явно обозначить тип возвращаемого значения замыкания.

###### **Вызов замыкания**
Замыкание, как анонимный блок кода, можно вызывать так же, как обычный метод. Если вы определяете замыкание без аргументов, например так:
```groovy
def code = { 123 }
```

То код внутри замыкания выполнится только при его вызове. Это можно сделать, обратившись к переменной, как к обычной функции:
```groovy
assert code() == 123
```

Либо можно быть более явным и использовать метод `call()`:
```groovy
assert code.call() == 123
```

Принцип остаётся тем же, если замыкание принимает аргументы:
```groovy
def isOdd = { int i -> i % 2 != 0 }   
assert isOdd(3) == true               
assert isOdd.call(2) == false         
```
> Здесь замыкание `isOdd` принимает параметр типа `int` и возвращает `true`, если число нечётное.

Можно использовать и неявный аргумент `it`:
```groovy
def isEven = { it % 2 == 0 }         
assert isEven(3) == false            
assert isEven.call(2) == true        
```
> В этом примере используется неявный параметр `it`, который доступен внутри замыкания, если явно не указаны другие параметры.

В отличие от метода, замыкание всегда возвращает значение при вызове. Даже если замыкание ничего не возвращает явно, оно всегда возвращает результат последнего выражения, и если это `println`, то результат — `null`.

###### **Обычные параметры**
Параметры замыканий в Groovy следуют тем же правилам, что и параметры обычных методов:
- тип может быть указан необязательно
- обязательно указывается имя параметра
- может быть указан параметр по умолчанию
- Параметры разделяются запятыми

Примеры:
```groovy
def closureWithOneArg = { str -> str.toUpperCase() }
assert closureWithOneArg('groovy') == 'GROOVY'
```
> Замыкание с одним параметром без указания типа.

```groovy
def closureWithOneArgAndExplicitType = { String str -> str.toUpperCase() }
assert closureWithOneArgAndExplicitType('groovy') == 'GROOVY'
```
> Замыкание с одним типизированным параметром.

```groovy
def closureWithTwoArgs = { a, b -> a + b }
assert closureWithTwoArgs(1, 2) == 3
```
> Замыкание с двумя параметрами без типов.

```groovy
def closureWithTwoArgsAndExplicitTypes = { int a, int b -> a + b }
assert closureWithTwoArgsAndExplicitTypes(1, 2) == 3
```
> Замыкание с двумя типизированными параметрами.

```groovy
def closureWithTwoArgsAndOptionalTypes = { a, int b -> a + b }
assert closureWithTwoArgsAndOptionalTypes(1, 2) == 3
```
> Замыкание с одним параметром без типа и одним типизированным.

```groovy
def closureWithTwoArgAndDefaultValue = { int a, int b = 2 -> a + b }
assert closureWithTwoArgAndDefaultValue(1) == 3
```
> Замыкание с параметром `b` по умолчанию — если передаётся только одно значение, второе берётся как `2`.

###### **Неявный параметр**
Если замыкание не определяет явно список параметров (то есть без использования `->`), то в Groovy замыкание автоматически получает один неявный параметр с именем `it`.

Это означает, что следующий код:
```groovy
def greeting = { "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'
```
полностью эквивалентен следующему:
```groovy
def greeting = { it -> "Hello, $it!" }
assert greeting('Patrick') == 'Hello, Patrick!'
```

Если вы хотите определить замыкание, которое не принимает никаких аргументов и должно вызываться только без аргументов, то необходимо явно указать пустой список параметров:
```groovy
def magicNumber = { -> 42 }
```
В этом случае следующий вызов вызовет ошибку, потому что замыкание не принимает аргументов:
```groovy
magicNumber(11) // Ошибка
```


###### **Переменное число аргументов (Varargs)**
В Groovy замыкание может принимать переменное число аргументов, так же как и обычный метод. Это означает, что если последний параметр замыкания — массив или varargs (синтаксис с троеточием `...`), то можно передавать любой объём значений без явной упаковки их в массив.

Примеры:
```groovy
def concat1 = { String... args -> args.join('') }
assert concat1('abc', 'def') == 'abcdef'
```
> Замыкание принимает переменное число строк и объединяет их в одну.  
> Аргументы можно передавать напрямую, без создания массива.

```groovy
def concat2 = { String[] args -> args.join('') }
assert concat2('abc', 'def') == 'abcdef'
```
> Поведение такое же, если параметр объявлен как массив.

```groovy
def multiConcat = { int n, String... args ->
    args.join('') * n
}
assert multiConcat(2, 'abc', 'def') == 'abcdefabcdef'
```
> Замыкание принимает один числовой аргумент `n` и переменное число строк. Все строки объединяются и дублируются `n` раз.

###### **Замыкания Groovy против лямбда-выражений Java**
В Groovy замыкания реализуются как экземпляры класса `groovy.lang.Closure`, что существенно отличает их от лямбда-выражений, появившихся в Java 8.

Главное отличие — механизм делегирования (delegation), который является ключевой концепцией в Groovy и не имеет прямого аналога в Java-лямбдах.

Благодаря возможности менять делегата (delegate) и стратегию делегирования (delegation strategy), замыкания в Groovy позволяют строить выразительные и элегантные DSL'ы (доменно-специфические языки) — то, за что Groovy особенно ценят.

###### **`this`, `owner` и `delegate` в замыканиях**
Чтобы понять, как работает делегирование, важно различать три связанных, но разных понятия внутри замыкания:
1. `this` - Ссылается на класс, в котором определено замыкание.
    
2. `owner` - Ссылается на объект, в котором определено замыкание. Это может быть:
    - либо класс (если замыкание определено прямо в нём),
    - либо другое замыкание (если замыкание вложенное).
        
3. `delegate` - Это объект-посредник, к которому будут перенаправлены обращения к методам и свойствам, если они не найдены у `this` или `owner`. Делегата можно назначить вручную, и это основа для построения DSL'ов и динамических сценариев.
    
###### **Значение `this` в замыкании**
Внутри замыкания вызов `getThisObject()` возвращает объект класса, внутри которого замыкание было определено. Это эквивалентно использованию `this` напрямую.

Пример:
```groovy
class Enclosing {
    void run() {
        def whatIsThisObject = { getThisObject() }
        assert whatIsThisObject() == this

        def whatIsThis = { this }
        assert whatIsThis() == this
    }
}
```
> Замыкание определено внутри класса `Enclosing`, поэтому `this` и `getThisObject()` ссылаются на экземпляр класса `Enclosing`.

Вложенные классы и `this`:
```groovy
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { this }
    }

    void run() {
        def inner = new Inner()
        assert inner.cl() == inner
    }
}
```
> Если замыкание определено внутри вложенного класса, то `this` в нём будет ссылаться на экземпляр вложенного класса, а не на внешний.

Вложенные замыкания:
```groovy
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { this }
            cl()
        }
        assert nestedClosures() == this
    }
}
```
> При определении одного замыкания внутри другого:
- `cl` определено внутри `nestedClosures` 
- но `this` ссылается на ближайший внешний класс, а не на `nestedClosures`

Вызов методов внешнего класса через `this`
```groovy
class Person {
    String name
    int age

    String toString() { "$name is $age years old" }

    String dump() {
        def cl = {
            String msg = this.toString()
            println msg
            msg
        }
        cl()
    }
}

def p = new Person(name: 'Janice', age: 74)
assert p.dump() == 'Janice is 74 years old'
```
> Внутри замыкания вызывается `this.toString()`, и это приводит к вызову метода `toString()` у внешнего объекта `Person`, потому что `this` ссылается на экземпляр класса `Person`.

###### **Владелец (owner) замыкания**
Понятие `owner` (владелец) в замыкании очень похоже на `this`, но с тонким отличием: `owner` возвращает непосредственный окружающий объект, которым может быть класс или другое замыкание.

Пример 1: Замыкание в классе
```groovy
class Enclosing {
    void run() {
        def whatIsOwnerMethod = { getOwner() }
        assert whatIsOwnerMethod() == this

        def whatIsOwner = { owner }
        assert whatIsOwner() == this
    }
}
```
- Здесь замыкание определено внутри метода класса `Enclosing`.  
- И `getOwner()` и `owner` ссылаются на `this`, то есть экземпляр `Enclosing`.

Пример 2: Замыкание во вложенном классе
```groovy
class EnclosedInInnerClass {
    class Inner {
        Closure cl = { owner }
    }

    void run() {
        def inner = new Inner()
        assert inner.cl() == inner
    }
}
```
- Замыкание `cl` определено внутри класса `Inner`.  
- Значит, `owner` — это экземпляр `Inner`, а не внешний класс.

Пример 3: Вложенные замыкания
```groovy
class NestedClosures {
    void run() {
        def nestedClosures = {
            def cl = { owner }
            cl()
        }
        assert nestedClosures() == nestedClosures
    }
}
```
- `nestedClosures` — внешнее замыкание  
- `cl` — внутреннее замыкание, определённое внутри `nestedClosures`  
- Поэтому `owner` для `cl` — это `nestedClosures`, то есть внешнее замыкание

###### **delegate замыкания**
`delegate` может быть получен с помощью свойства `delegate` или методом `getDelegate()`. Это мощный механизм, особенно полезный при создании DSL (доменно-специфических языков) в Groovy.

В то время как `this` и `owner` относятся к лексическому контексту (где замыкание определено), `delegate` — это объект, задаваемый пользователем, с которым замыкание будет работать при вызовах методов и обращении к свойствам.

По умолчанию `delegate` устанавливается равным `owner`.

Пример:
```groovy
class Enclosing {
    void run() {
        def cl = { getDelegate() }
        def cl2 = { delegate }

        assert cl() == cl2()
        assert cl() == this

        def enclosed = {
            { -> delegate }.call()   // вложенное замыкание
        }

        assert enclosed() == enclosed  // delegate вложенного замыкания = owner = enclosed
    }
}
```

Делегата можно переопределить вручную — на любой объект.
Представим две независимые друг от друга сущности:
```groovy
class Person {
    String name
}
class Thing {
    String name
}

def p = new Person(name: 'Norman')
def t = new Thing(name: 'Teapot')
```

Теперь создадим замыкание, которое обращается к свойству `name` у делегата:
```groovy
def upperCasedName = { delegate.name.toUpperCase() }
```

Меняя делегата, мы меняем и поведение замыкания:
```groovy
upperCasedName.delegate = p
assert upperCasedName() == 'NORMAN'

upperCasedName.delegate = t
assert upperCasedName() == 'TEAPOT'
```
Замыкание стало работать с разными объектами без изменения его кода.


###### **Стратегия делегирования**
Когда внутри замыкания происходит обращение к свойству без явного указания получателя (receiver), в работу вступает стратегия делегирования.

Пример:
```groovy
class Person {
    String name
}

def p = new Person(name: 'Igor')

def cl = { name.toUpperCase() }     // нет переменной name в лексической области видимости

cl.delegate = p                     // устанавливаем делегата — объект Person

assert cl() == 'IGOR'
```
Разбор:
- В замыкании `name` — это не переменная, а свойство, которое Groovy будет искать в контексте замыкания.
- Делегат установлен на объект `p`, и Groovy находит свойство `name` у `delegate`.
- Всё работает прозрачно, даже без `delegate.name`.
Это мощный способ делать вызовы и доступ к данным внутри DSL, без жёсткой привязки к контексту.

Groovy использует стратегию разрешения, чтобы понять, где искать методы и свойства в замыкании. По умолчанию применяется стратегия `OWNER_FIRST`.

###### **Cтратегии делегирования**
Groovy предоставляет несколько встроенных стратегий:

| Стратегия                            | Описание                                                                                  |
| ------------------------------------ | ----------------------------------------------------------------------------------------- |
| `Closure.OWNER_FIRST` (по умолчанию) | Сначала ищет свойство/метод у owner, если не найдено — у `delegate`                       |
| `Closure.DELEGATE_FIRST`             | Сначала ищет у delegate, затем у `owner`                                                  |
| `Closure.OWNER_ONLY`                 | Ищет только у owner, делегат игнорируется                                                 |
| `Closure.DELEGATE_ONLY`              | Ищет только у delegate, owner игнорируется                                                |
| `Closure.TO_SELF`                    | Ищет только внутри класса Closure, используется при кастомной логике метапрограммирования |

Допустим, у нас есть два класса, **`Person`** и **`Thing`**, у которых пересекаются и различаются поля. Мы хотим, чтобы замыкание работало с разными объектами в зависимости от стратегии.
```groovy
class Person {
    String name = 'Alice'
    int age = 30

    def describe = {
        "Name: $name, Age: $age"
    }
}

class Thing {
    String name = 'Kettle'
    String type = 'Appliance'
}
```

`OWNER_FIRST` (стратегия по умолчанию)
```groovy
def person = new Person()
def thing = new Thing()

def cl = person.describe
cl.delegate = thing
cl.resolveStrategy = Closure.OWNER_FIRST

println "OWNER_FIRST -> " + cl()  
```
Результат:  
`Name: Alice, Age: 30`


`DELEGATE_FIRST`
```groovy
cl.resolveStrategy = Closure.DELEGATE_FIRST

println "DELEGATE_FIRST -> " + cl()
```

###### **Функциональное программирование**
Замыкания (closures), так же как и лямбда-выражения в Java 8, лежат в основе парадигмы функционального программирования в Groovy.  
Некоторые операции функционального программирования доступны непосредственно в классе `Closure`, как показано в этом разделе.

###### **Каррирование (Currying)**
В Groovy каррированием называется приём частичного применения аргументов. Это не совсем то же самое, что классическое каррирование в функциональном программировании, из-за отличий в области видимости (scoping) замыканий в Groovy.
Каррирование позволяет зафиксировать значение одного из параметров замыкания, возвращая при этом новое замыкание, которое принимает на один параметр меньше.

###### **Левое каррирование (Left currying)**
Левое каррирование означает задание значения самого левого параметра замыкания. Пример:
```groovy
def nCopies = { int n, String str -> str * n }    
def twice = nCopies.curry(2)                      
assert twice('bla') == 'blabla'                   
assert twice('bla') == nCopies(2, 'bla')          
```
Разбор:
- Замыкание `nCopies` принимает два параметра: `n` и `str`
- Метод `curry(2)` задаёт значение первого параметра (`n = 2`), и возвращает новое замыкание, которое теперь принимает только строку    
- Вызов `twice('bla')` эквивалентен вызову `nCopies(2, 'bla')`
    

###### **Правое каррирование (Right currying)**
Аналогично левому каррированию, в Groovy можно зафиксировать значение самого правого параметра замыкания:
```groovy
def nCopies = { int n, String str -> str * n }
def blah = nCopies.rcurry('bla')               
assert blah(2) == 'blabla'                     
assert blah(2) == nCopies(2, 'bla')
```
    

###### **Каррирование по индексу (Index-based currying)**
Если замыкание принимает более двух параметров, можно зафиксировать любой параметр по индексу с помощью метода `ncurry`:
```groovy
def volume = { double l, double w, double h -> l * w * h }

def fixedWidthVolume = volume.ncurry(1, 2d)
assert volume(3d, 2d, 4d) == fixedWidthVolume(3d, 4d)

def fixedWidthAndHeight = volume.ncurry(1, 2d, 4d)
assert volume(3d, 2d, 4d) == fixedWidthAndHeight(3d)
```
Разбор:
- Функция `volume` принимает три параметра: `длина`, `ширина`, `высота`    
- `volume.ncurry(1, 2d)` — фиксирует второй параметр (`width = 2.0`)  
    → новое замыкание принимает `length` и `height`
- `volume.ncurry(1, 2d, 4d)` — фиксирует сразу ширину и высоту  
    → новое замыкание принимает только `length`

###### **Мемоизация (Memoization)**
Мемоизация — это техника, позволяющая кешировать результат вызова замыкания. Она особенно полезна, когда функция:
- выполняет дорогостоящие вычисления
- но часто вызывается с одними и теми же аргументами
    

Пример: медленная реализация Фибоначчи
```groovy
def fib
fib = { long n -> n < 2 ? n : fib(n - 1) + fib(n - 2) }
assert fib(15) == 610  // медленно!
```
В чём проблема:
- Алгоритм рекурсивный и повторно вычисляет одни и те же значения
- Например:
    - `fib(15)` вызывает `fib(14)` и `fib(13)`
    - `fib(14)` снова вызывает `fib(13)` и `fib(12)`
- Это приводит к экспоненциальной сложности

Оптимизация с помощью `.memoize()`
```groovy
fib = { long n -> n < 2 ? n : fib(n - 1) + fib(n - 2) }.memoize()
assert fib(25) == 75025  // быстро!
```
- Что делает `.memoize()`:
	- Кеширует результаты вызовов замыкания с определёнными аргументами
	- Если `fib(13)` уже считан, повторный вызов просто вернёт результат из кеша

> Мемоизация работает по значению аргументов.  
> Поэтому она лучше всего подходит для примитивных или обёрнутых типов (int, long, String и т.п.)
> Если использовать объекты с нестабильным `hashCode()` или `equals()`, кеш может работать непредсказуемо.

###### **Расширенные методы кеширования:**

| Метод                  | Описание                                                   |
| ---------------------- | ---------------------------------------------------------- |
| `.memoize()`           | Кеширует все значения без ограничения                      |
| `.memoizeAtMost(n)`    | Кеширует не более `n` значений (LRU)                       |
| `.memoizeAtLeast(n)`   | Гарантирует хранение как минимум `n` значений              |
| `.memoizeBetween(a,b)` | Кеширует от `a` до `b` значений — нижняя и верхняя граница |

Все варианты используют LRU-кеш (Least Recently Used), т.е. старые значения постепенно вытесняются.

###### **Композиция замыканий (Closure composition)**
Композиция замыканий в Groovy — это концепция функционального программирования, позволяющая создавать новые функции путём объединения нескольких. То есть, результат одного замыкания подаётся на вход другому.

Пример:
```groovy
def plus2  = { it + 2 }
def times3 = { it * 3 }

def times3plus2 = plus2 << times3  // сначала times3, потом plus2
assert times3plus2(3) == 11        // 3 * 3 + 2 = 11
assert times3plus2(4) == plus2(times3(4))
```
Оператор `<<` означает: `f << g` → `f(g(x))`

```groovy
def plus2times3 = times3 << plus2
assert plus2times3(3) == 15        // (3 + 2) * 3 = 15
assert plus2times3(5) == times3(plus2(5))
```

###### **Обратная композиция:**
```groovy
assert times3plus2(3) == (times3 >> plus2)(3)
```
Оператор `>>` также выполняет композицию, но в обратном порядке:
`f >> g` → `g(f(x))`  
То есть: `plus2 << times3` = `times3 >> plus2`

###### **(Trampoline) для рекурсии**
Рекурсивные алгоритмы в обычном виде могут привести к переполнению стека (StackOverflowError) при слишком глубокой рекурсии.
Groovy решает это с помощью трамплина (trampoline).
- `Closure` оборачивается в специальную `TrampolineClosure`
- Если результат вызова — другое замыкание, оно тоже вызывается
- Повторяется до тех пор, пока не вернётся обычное значение
- Таким образом стек не растёт, а вызовы происходят последовательно (итеративно)
    
Пример: факториал с `trampoline()`
```groovy
def factorial
factorial = { int n, def accu = 1G ->
    if (n < 2) return accu
    factorial.trampoline(n - 1, n * accu)
}
factorial = factorial.trampoline() // обернули в TrampolineClosure

assert factorial(1)    == 1
assert factorial(3)    == 1 * 2 * 3
assert factorial(1000) // работает, несмотря на глубину
```
Используется `1G` (BigInteger), чтобы избежать переполнения по значению `trampoline()` предотвращает переполнение стека, которое случилось бы в обычной рекурсии
