###### **Command chains**
Groovy позволяет опускать круглые скобки вокруг аргументов при вызове методов на верхнем уровне. Функция "цепочка команд" (command chain) расширяет эту возможность, позволяя объединять такие вызовы методов в цепочку без скобок и точек между вызовами. Общий принцип таков: выражение вроде `a b c d` будет интерпретировано как `a(b).c(d)`.

Это работает не только с одиночными аргументами, но и с несколькими аргументами, замыканиями (closures) и даже именованными параметрами. Более того, такие цепочки команд можно использовать и в правой части выражений присваивания. Ниже представлены примеры, демонстрирующие работу нового синтаксиса:
```groovy
// эквивалентно: turn(left).then(right)
turn left then right

// эквивалентно: take(2.pills).of(chloroquinine).after(6.hours)
take 2.pills of chloroquinine after 6.hours

// эквивалентно: paint(wall).with(red, green).and(yellow)
paint wall with red, green and yellow

// с именованными параметрами
// эквивалентно: check(that: margarita).tastes(good)
check that: margarita tastes good

// с замыканиями в качестве аргументов
// эквивалентно: given({}).when({}).then({})
given { } when { } then { }
```
Этот синтаксис делает код Groovy более выразительным и читаемым, особенно в DSL-подобных конструкциях.

Также в цепочке команд можно использовать методы без аргументов, однако в этом случае необходимо использовать круглые скобки:
```groovy
// эквивалентно: select(all).unique().from(names)
select all unique() from names
```

Если в вашей цепочке команд нечётное количество элементов, то она будет интерпретироваться как последовательность вызовов методов с аргументами и завершится доступом к свойству:
```groovy
// эквивалентно: take(3).cookies
// или: take(3).getCookies()
take 3 cookies
```

Подход с цепочками команд открывает широкие возможности для создания DSL (Domain-Specific Languages) — специализированных языков, теперь их можно писать на Groovy ещё выразительнее и гибче.

Выше приведены примеры использования DSL, основанного на цепочках команд. Но как такой DSL создать? Существует несколько стратегий, и для наглядности ниже приведены примеры — сначала с использованием map-структур и замыканий (Closures):
```groovy
show = { println it }
square_root = { Math.sqrt(it) }

def please(action) {
  [the: { what ->
    [of: { n -> action(what(n)) }]
  }]
}

// эквивалентно: please(show).the(square_root).of(100)
please show the square_root of 100
// ==> 10.0
```

Такой подход позволяет создавать элегантные, читаемые и интуитивно понятные DSL-конструкции, особенно полезные при описании сложных доменных логик.

Рассмотрим второй пример — создание DSL, который упрощает работу с уже существующим API. Допустим, вам нужно предоставить такой код клиентам, бизнес-аналитикам или тестировщикам, которые не являются опытными Java-разработчиками. В этом примере мы используем `Splitter` из библиотеки Google Guava, так как у него уже есть элегантный fluent-интерфейс. Вот как этот код выглядит «из коробки»:
```groovy
@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()
```
Для Java-разработчика этот код читается вполне понятно. Но если ваша аудитория — не технические специалисты, или вам нужно писать множество подобных строк, код может показаться слишком громоздким. Опять же, есть множество способов написать DSL, и мы рассмотрим один из них — на основе Map и замыканий (Closures). Сначала напишем вспомогательный метод:
```groovy
@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def split(string) {
  [on: { sep ->
    [trimming: { trimChar ->
      Splitter.on(sep).trimResults(CharMatcher.is(trimChar as char)).split(string).iterator().toList()
    }]
  }]
}
```

Теперь вместо длинной строки из оригинального примера:
```groovy
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()
```
мы можем написать гораздо более лаконичный и читаемый код:
```groovy
def result = split "_a ,_b_ ,c__" on ',' trimming '_'
```
Такой DSL делает код понятнее и доступнее для не-программистов и позволяет спрятать технические детали за простым и выразительным интерфейсом.