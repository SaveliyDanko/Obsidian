Инструкция логического сдвига влево в архитектуре x86_64 — это **`shl`** (Shift Left Logical). Она выполняет **логический сдвиг битов влево** в указанном операнде, заполняя младшие биты нулями. Это эквивалентно умножению числа на степень двойки.

### ==Синтаксис==
```asm
shl dest, count
```
- **`dest`** — операнд, который будет сдвигаться влево (может быть регистр или ячейка памяти).
- **`count`** — количество позиций для сдвига. Это может быть непосредственное значение (например, `2`) или значение в регистре `cl` (младший байт регистра `rcx`).

### ==Как работает `shl`==
При сдвиге:
1. Биты в операнде смещаются влево на указанное количество позиций.
2. Младшие биты заполняются нулями.
3. Старшие биты, выходящие за пределы операнда, теряются (выбрасываются).

### ==Пример использования==
```asm
mov rax, 3            ; rax = 3 (в двоичной: 0000...0011)
shl rax, 2            ; сдвиг влево на 2 позиции: rax = 12 (в двоичной: 0000...1100)
```
В этом примере:
- Число `3` (в двоичном виде `0000...0011`) сдвигается влево на 2 позиции, результат — `12` (в двоичном виде `0000...1100`).

### ==Пример с использованием регистра `cl`:==
```asm
mov rax, 1            ; rax = 1 (в двоичной: 0000...0001)
mov rcx, 4            ; rcx = 4
shl rax, cl           ; сдвиг на 4 позиции: rax = 16 (в двоичной: 0000...10000)
```
Здесь количество позиций для сдвига определяется регистром `cl` (младший байт `rcx`).

### ==Применение==
Инструкция `shl` используется для:
- Умножения числа на степень двойки.
- Манипуляции битами, таких как сдвиг полей в битовых масках.

### ==Флаги процессора==
- **CF (Carry Flag)**: Устанавливается, если бит, вытесняемый из старшего бита, равен 1.
- **ZF (Zero Flag)**: Устанавливается, если результат сдвига равен нулю.
- **SF (Sign Flag)**: Устанавливается, если старший бит результата равен 1 (только для знаковых операций).
- **OF (Overflow Flag)**: Устанавливается, если результат сдвига изменил знак числа (только если сдвиг производится на 1 бит).

### ==Пример для 64-битного числа:==
```asm
mov rax, 0x000000000000000F  ; rax = 15 (в двоичной: 0000...1111)
shl rax, 4                   ; сдвиг влево на 4 позиции: rax = 240 (в двоичной: 0000...11110000)
```
В этом примере число `15` сдвигается влево на 4 позиции, что эквивалентно умножению на 16 (результат — `240`).

### ==Отличие от арифметического сдвига==
- **`shl`** — это **логический сдвиг**, при котором биты просто перемещаются влево, а младшие заполняются нулями.
- В отличие от **арифметического сдвига**, `shl` не пытается сохранять знак числа — сдвиг происходит одинаково как для положительных, так и для отрицательных чисел.

Таким образом, команда логического сдвига влево `shl` полезна для множества операций с битами, особенно когда необходимо умножить число на степень двойки или манипулировать отдельными битами числа.