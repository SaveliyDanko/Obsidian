В x86_64 assembler'е (NASM) команды ветвления позволяют изменять поток выполнения программы в зависимости от определённых условий. Они основываются на результатах операций, которые влияют на флаги процессора, такие как:
- Zero Flag (ZF) — указывает на результат операции равный нулю.
- Sign Flag (SF) — указывает на знак результата (отрицательное или положительное число).
- Carry Flag (CF) — указывает на перенос или заём при арифметических операциях.
- Overflow Flag (OF) — указывает на переполнение при арифметических операциях.

### ==Безусловное ветвление==
Для безусловного изменения потока выполнения используется команда **`jmp`**.
#### `jmp` — безусловный переход
```nasm
jmp label
```
Программа просто переходит на метку `label`, не проверяя никаких условий.

### ==Условное ветвление==
Условные команды ветвления выполняют переход только при выполнении определённого условия, которое обычно проверяет флаги процессора. Все команды условного перехода начинаются с **`j`**, а затем следуют условия.

#### Основные условные команды ветвления
1. **`je` (Jump if Equal)** — переход, если результат предыдущей операции равен нулю (ZF = 1).
2. **`jne` (Jump if Not Equal)** — переход, если результат не равен нулю (ZF = 0).
3. **`jg` (Jump if Greater)** — переход, если результат больше (SF = 0, ZF = 0).
4. **`jl` (Jump if Less)** — переход, если результат меньше (SF ≠ OF).
5. **`jge` (Jump if Greater or Equal)** — переход, если результат больше или равен (SF = OF).
6. **`jle` (Jump if Less or Equal)** — переход, если результат меньше или равен (ZF = 1 или SF ≠ OF).
7. **`ja` (Jump if Above)** — переход, если результат больше (без знака) (CF = 0 и ZF = 0).
8. **`jb` (Jump if Below)** — переход, если результат меньше (без знака) (CF = 1).

### ==Пример условного ветвления==
Пример кода на NASM с условным ветвлением:
```nasm
section .data
    num1 dq 10
    num2 dq 20

section .text
    global _start

_start:
    ; Загрузка значений в регистры
    mov rax, [num1]
    mov rbx, [num2]

    ; Сравнение значений
    cmp rax, rbx
    je equal      ; Если rax == rbx, переход на метку equal

    ; Если не равны, продолжаем здесь
    jne notequal  ; Если rax != rbx, переход на метку notequal

equal:
    ; Код для случая, если числа равны
    ; ...
    jmp end

notequal:
    ; Код для случая, если числа не равны
    ; ...
    jmp end

end:
    ; Завершаем программу
    mov rax, 60   ; системный вызов для выхода
    xor rdi, rdi  ; код возврата 0
    syscall
```

### ==Использование команды `cmp`==
Для большинства условных ветвлений предварительно используется команда **`cmp`**. Она вычитает второе значение из первого, обновляет флаги процессора на основе результата, но не сохраняет результат в регистрах. После этого может использоваться одна из команд условного перехода для изменения потока программы.
```nasm
cmp rax, rbx  ; сравнение rax и rbx
```

Флаги обновляются в зависимости от результата:
- Если `rax == rbx`, устанавливается Zero Flag (ZF).
- Если `rax > rbx`, флаги SF и OF обновляются соответственно.

### ==Комбинирование с циклами==
Команды условного ветвления также используются для создания циклов. Пример простого цикла с уменьшением значения регистра:
```nasm
section .text
    global _start

_start:
    mov rax, 10   ; Инициализация счетчика

loop_start:
    cmp rax, 0    ; Проверка: достигли ли нуля?
    je loop_end   ; Если да, выйти из цикла

    ; Тело цикла
    ; ...

    dec rax       ; Уменьшаем rax
    jmp loop_start ; Переход в начало цикла

loop_end:
    mov rax, 60   ; системный вызов для выхода
    xor rdi, rdi  ; код возврата 0
    syscall
```

### ==Заключение==
Ветвление в x86_64 assembler используется для управления потоком выполнения программы. Команды ветвления могут быть условными и безусловными, и их работа зависит от состояния флагов процессора, обновляемых после арифметических операций или операций сравнения.