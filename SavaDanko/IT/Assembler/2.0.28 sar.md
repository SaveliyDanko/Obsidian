Инструкция `sar` (Shift Arithmetic Right) в архитектуре x86_64 выполняет **арифметический сдвиг вправо**. В отличие от логического сдвига (инструкция `shr`), при арифметическом сдвиге старшие биты заполняются **значением знакового бита**, то есть значением старшего бита операнда. Это позволяет сохранять знак числа при сдвиге.

### ==Синтаксис==
```asm
sar dest, count
```
- `dest` — это операнд, который будет сдвигаться вправо. Это может быть регистр или ячейка памяти.
- `count` — это количество позиций, на которое необходимо сдвинуть биты. Это может быть либо непосредственное значение, либо значение в регистре `cl`.

### ==Как работает `sar`:==
- **Для положительных чисел**: инструкция `sar` работает аналогично инструкции `shr` (логический сдвиг). Старшие биты заполняются нулями.
- **Для отрицательных чисел**: старшие биты заполняются единицами, чтобы сохранить знак числа (используется знаковое расширение).

### ==Пример использования==
```asm
mov rax, -16          ; rax = 0xFFFFFFFFFFFFFFF0 (в 64 битах)
sar rax, 1            ; сдвиг на 1 бит: rax = 0xFFFFFFFFFFFFFFF8
```

### ==Пояснение:==
- Перед сдвигом: `rax = 0xFFFFFFFFFFFFFFF0` (в двоичной форме: `1111 1111 1111 1111 ... 1111 1111 1111 0000`).
- После сдвига: старшие биты заполняются единицами (сохраняется знак числа). Получаем `rax = 0xFFFFFFFFFFFFFFF8` (в двоичной форме: `1111 1111 1111 1111 ... 1111 1111 1111 1000`).

### ==Пример с использованием регистра `cl`:==
Когда количество сдвигов задается регистром, используется младший байт регистра `rcx` — регистр `cl`:
```asm
mov rax, -128         ; rax = 0xFFFFFFFFFFFFFF80
mov rcx, 4            ; rcx = 4
sar rax, cl           ; сдвиг на 4 бита: rax = 0xFFFFFFFFFFFFFFF8
```

### ==Отличие от `shr`:==
- **`shr` (логический сдвиг)**: заполняет старшие биты нулями.
- **`sar` (арифметический сдвиг)**: сохраняет знак, заполняя старшие биты значением знакового бита (старшего бита).

### ==Флаги процессора:==
- **CF (Carry Flag)**: Не определен при использовании инструкции `sar`.
- **ZF (Zero Flag)**: Устанавливается, если результат сдвига равен нулю.
- **SF (Sign Flag)**: Устанавливается, если результат сдвига отрицателен.
- **OF (Overflow Flag)**: Сбрасывается, если сдвиг производится на более чем один бит, иначе — установлен, если знак изменился.

### ==Пример для 64-битного числа:==
```asm
mov rax, -64            ; rax = 0xFFFFFFFFFFFFFFC0 (отрицательное число)
sar rax, 3              ; rax = 0xFFFFFFFFFFFFFFF8 (сдвиг на 3 бита)
```
В этом примере старшие биты заполняются единицами, сохраняя знак отрицательного числа.

Таким образом, команда `sar` полезна для операций, где нужно сохранить знак числа при выполнении сдвига вправо.