Обмен данными между ЦПУ и памятью — ключевая часть вычислений в компьютере с архитектурой фон Неймана. Инструкции и операнды считываются из памяти, а некоторые результаты сохраняются в память. Это создает узкое место, так как процессор может простаивать в ожидании данных. Чтобы избежать этого, процессор оснащается регистрами — небольшими, но быстрыми ячейками памяти, расположенными прямо в процессоре. 

Однако существуют ограничения:
- Регистры дороги.
- Инструкции кодируют номера регистров, что увеличивает размер инструкций.
- Большое количество регистров усложняет схемы процессора, что делает их сложнее и медленнее.

Программы обычно пишутся с учетом **локальности ссылок**:
1. **Временная локальность** — обращение к одному адресу с высокой вероятностью будет происходить в близкие моменты времени.
2. **Пространственная локальность** — после обращения к адресу \(X\) следующие обращения к памяти будут рядом (например, \(X-16\) или \(X+28\)).

Программы используют небольшие рабочие наборы данных, которые могут храниться в регистрах, что снижает необходимость обращения к основной памяти. Однако, если регистры заполнены, часть данных придется выгружать в память, что приводит к потере производительности.

Для систем реального времени снижение производительности в худшем случае недопустимо, так как такие системы должны реагировать на события в строго ограниченное время.

---

## ==General Purpose Registers==
Программисты в основном работают с **регистрами общего назначения**. Эти регистры взаимозаменяемы и могут использоваться в разных командах. 

### Основные особенности:
- **64-битные регистры** имеют имена: `r0, r1, …, r15`. Первые восемь регистров имеют альтернативные названия, которые несут смысл для некоторых специальных инструкций.
    - Пример: `r1 = rcx`, используется как счетчик циклов в инструкции `loop`, которая не принимает операндов.
  
- Регистры не имеют адресов, как ячейки основной памяти, так как они представляют собой особый тип памяти.

- Альтернативные имена используются чаще по историческим причинам. Например, `rax` как аккумулятор для арифметических операций, `rbx` как базовый регистр, `rcx` для циклов, `rsp` для хранения адреса верхнего элемента стека и т.д.

### Основные регистры:
- **`rax`** (`r0`): используется как аккумулятор для арифметических операций.
- **`rcx`** (`r1`): используется для циклов, как счетчик.
- **`rdx`** (`r2`): хранит данные во время операций ввода/вывода.
- **`rbx`** (`r3`): ранее использовался для базовой адресации.
- **`rsp`** (`r4`): хранит адрес верхнего элемента аппаратного стека.
- **`rbp`** (`r5`): используется как базовый указатель стека.
- **`rsi`** (`r6`): исходный индекс в строковых операциях.
- **`rdi`** (`r7`): конечный индекс в строковых операциях.

### Работа с частями регистров:
- Можно адресовать меньшие части регистров (32-битные, 16-битные и 8-битные части) с помощью суффиксов:
    - **d** — нижние 32 бита,
    - **w** — нижние 16 бит,
    - **b** — нижние 8 бит.
  
- Примеры:
    - **`r7b`** — младший байт регистра `r7`.
    - **`r3w`** — два младших байта регистра `r3`.
    - **`r0d`** — четыре младших байта регистра `r0`.

### Особенности записи:
- При записи в 32-битные части регистров, старшие 32 бита заполняются знаковыми битами. Например, запись нуля в `eax` обнуляет весь `rax`.
- Запись в 16-битные части не изменяет остальные биты.

---
## ==Other registers==
В дополнение к общим регистрам существуют регистры со специальным назначением, которые важны на системном уровне и не могут быть изменены программистом напрямую — только операционной системой.

- **rip** — 64-битный регистр, хранящий адрес следующей инструкции для исполнения. Ветвящиеся инструкции (например, `jmp`) изменяют его значение. Каждый раз, когда выполняется инструкция, в **rip** записывается адрес следующей инструкции.

- **rflags** — регистр, который хранит флаги, отражающие текущее состояние программы (например, результат последней арифметической операции: был ли он отрицательным, произошел ли переполнение и т.д.). Младшие части **rflags**:
    - **eflags** (32 бита),
    - **flags** (16 бит).

### Основные флаги:
- **CF** (Carry Flag) — устанавливается, если при сложении/вычитании произошло заимствование или перенос (переполнение).
- **AF** (Auxiliary Flag) — используется для определения ошибок при операции с четырьмя младшими битами байта, часто в контексте двоично-десятичных вычислений.
- **ZF** (Zero Flag) — устанавливается, если результат последней операции равен нулю.
- **OF** (Overflow Flag) — указывает на переполнение при арифметических операциях со знаком.
- **SF** (Sign Flag) — отражает знак результата последней арифметической операции: если результат отрицательный, **SF** устанавливается.

### Различие между **OF** и **CF**:
- **CF** указывает на перенос или заимствование при арифметических операциях без учета знака (например, при сложении или вычитании целых чисел).
- **OF** сигнализирует о переполнении при работе с числами со знаком, когда результат не может быть корректно представлен в имеющемся количестве бит.

### Дополнительные регистры:
- **`xmm0 - xmm15`** — 128-битные регистры для операций с числами с плавающей точкой и параллельными инструкциями (например, для ускорения мультимедийных задач).

---
## ==System registers==
Некоторые регистры предназначены исключительно для использования операционной системой. Они не хранят значения, используемые в вычислениях, а служат для хранения информации, необходимой для системных структур данных. Их основная роль — поддержка инфраструктуры, которая создаётся благодаря взаимодействию ОС и процессора. Эта инфраструктура изолирует приложения друг от друга и от системы, управляет ресурсами прозрачно для программиста.

Ключевое значение имеет то, что эти регистры недоступны для приложений и не могут быть ими изменены. Это обеспечивается **привилегированным режимом**.

#### Пример системных регистров:
- **`cr0, cr4`** — хранят флаги, связанные с различными режимами процессора и виртуальной памятью.
- **`cr2, cr3`** — поддерживают виртуальную память.
- **`cr8 (или tpr)`** — регулирует механизм прерываний 
- **`efer`** — регистр флагов, управляющий режимами процессора и расширениями, такими как долгий режим и обработка системных вызовов.
- **`idtr`** — хранит адрес таблицы дескрипторов прерываний.
- **`gdtr, ldtr`** — хранят адреса таблиц дескрипторов 
- **`cs, ds, ss, es, gs, fs`** — сегментные регистры, часть механизма сегментации, который считается устаревшим, но всё ещё используется для реализации привилегированного режима.

Сегментация применяется для поддержки механизмов, связанных с привилегиями и безопасностью, хотя её использование в современных системах минимизировано.

---
## ==Protection Rings==
**Кольца защиты** — это один из механизмов, разработанных для ограничения возможностей приложений в целях безопасности и устойчивости системы. Они были изобретены для операционной системы Multics, прямого предшественника Unix. Каждое кольцо соответствует определённому уровню привилегий. Тип каждой инструкции связан с одним или несколькими уровнями привилегий и не может быть выполнен на других уровнях. Текущий уровень привилегий хранится, например, в специальном регистре.

**Intel 64** поддерживает четыре уровня привилегий, но на практике используются только два:
- **Кольцо 0 (ring-0)** — самый привилегированный уровень, обычно используется ядром ОС.
- **Кольцо 3 (ring-3)** — наименьший уровень привилегий, предназначенный для пользовательских приложений.

Средние уровни (кольца 1 и 2) изначально планировались для драйверов и сервисов ОС, но популярные операционные системы не приняли эту концепцию.

В **долгом режиме** (long mode) текущий номер кольца защиты хранится в двух младших битах регистра **cs** (и дублируется в биты регистра **`ss`**). Это значение может быть изменено только при обработке прерывания или системного вызова, что не позволяет приложению произвольно исполнять код с повышенными привилегиями. Приложение может только вызывать обработчик прерываний или выполнять системный вызов.

---
## ==Hardware Stack==
Стек — это структура данных, которая позволяет добавлять элементы (операция **push**) и извлекать их (операция **pop**). В аппаратуре стека нет отдельной памяти, он эмулируется с помощью инструкций **push** и **pop** и регистра **`rsp`**. Регистры и память взаимодействуют следующим образом:

1. **push**: 
   - Значение регистра **`rsp`** уменьшается на 2, 4 или 8 байт в зависимости от размера аргумента.
   - Аргумент записывается в память по адресу, хранящемуся в модифицированном **`rsp`**.
   
2. **pop**:
   - Верхний элемент стека копируется в регистр или память.
   - Значение **`rsp`** увеличивается на размер аргумента.

Стек используется для сохранения контекста при вызове функций: например, при вызове функции B из функции A стек сохраняет информацию о состоянии программы, чтобы по завершению функции B можно было вернуться в функцию A.

#### Основные факты о стеке:
1. **Пустой стек**: Стек никогда не бывает полностью пустым; инструкция **pop** вернет элемент, даже если ни одной команды **push** не было выполнено.
2. **Рост стека**: Стек растет в сторону уменьшения адресов памяти (к нулевому адресу).
3. **Знаковое расширение**: Операнды стека считаются знаковыми целыми числами. Например, если выполнить **push** с аргументом `B9h`, на стеке будет сохранено значение `0xffb9`, а при использовании 8-байтового операнда `0xfffffffffffffff9`.
4. **Адрес вершины стека**: В зависимости от архитектуры, адрес вершины стека может указывать либо на последний элемент стека, либо на место для записи следующего элемента.

#### Инструкция **push** в 64-битном режиме:
В документации Intel для инструкции **push** вы найдете таблицу с кодами операций (OPCODE), допустимыми типами операндов и описанием эффектов. Инструкция **push** может принимать операнды разных типов, таких как регистры, память или немедленные значения. Например:
- **`push r/m16`** — помещает 16-битный регистр или значение из памяти в стек.
- **`push CS`** — помещает регистр сегмента **cs** в стек.

#### Когда операнд инструкции **push** не подвергается знаковому расширению:
Операнд не подвергается знаковому расширению, если используется в командах с явным размером операндов, например, с 8-байтовыми или 16-битными значениями. Знаковое расширение обычно применимо к целым числам с меньшими разрядами (например, 1 байт или 2 байта), когда их переносят в регистры большего размера.

#### Влияние инструкции **`push rsp`** на память и регистры:
1. Значение регистра **`rsp`** уменьшается на 8 байт.
2. Текущее значение **`rsp`** сохраняется в памяти по новому значению регистра **`rsp`** (то есть в новую вершину стека).
