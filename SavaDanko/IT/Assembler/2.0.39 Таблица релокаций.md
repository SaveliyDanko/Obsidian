**Таблица релокаций** (Relocation Table) — это структура данных, которая создаётся компилятором на этапе компиляции программы. Она содержит информацию о том, какие участки объектного кода нужно модифицировать или "переместить" во время компоновки или загрузки программы в память. Это необходимо, потому что на этапе компиляции компилятор не всегда может знать точные адреса переменных и функций.

### ==Основная задача таблицы релокаций==
Таблица релокаций используется для того, чтобы откорректировать ссылки на адреса функций, переменных, или других элементов программы, когда она загружается в память или связывается с другими объектными файлами. Это особенно важно для программ, состоящих из нескольких модулей или при динамическом связывании библиотек.

### ==Когда используется таблица релокаций==
1. **Ссылки на внешние символы**:
   - Если в одном объектном файле (например, `a.o`) есть ссылка на функцию или переменную, которая определена в другом объектном файле (например, `b.o`), таблица релокаций указывает компоновщику, что нужно заменить место вызова этой функции или использования переменной правильным адресом после того, как все объектные файлы будут объединены.

2. **Использование относительных адресов**:
   - Иногда программа использует относительные адреса для переходов или доступа к данным. После того как программа загружается в память, эти относительные адреса могут измениться, и таблица релокаций позволяет корректировать такие ссылки.

3. **Динамическая загрузка библиотек**:
   - В случае динамической загрузки библиотек таблица релокаций также помогает при связывании динамических символов, таких как функции из внешних библиотек.

### ==Пример использования таблицы релокаций==
Представьте, что у вас есть программа на ассемблере, которая вызывает функцию, определённую в другом файле:
```asm
; main.asm
extern my_function       ; Объявляем, что функция находится в другом модуле
section .text
    global _start

_start:
    call my_function      ; Вызов функции
```

```asm
; my_function.asm
section .text
    global my_function

my_function:
    ; Реализация функции
    ret
```
Когда компилируются оба этих файла, объектный файл `main.o` не будет знать, где точно находится функция `my_function`, пока они не будут скомпонованы вместе. Поэтому в объектном файле `main.o` будет создана **запись в таблице релокаций**, которая укажет компоновщику, что адрес вызова `my_function` нужно заполнить правильным значением при связывании с объектным файлом `my_function.o`.

### ==Структура таблицы релокаций==
В таблице релокаций хранится информация о том, какие адреса в объектном файле должны быть изменены во время компоновки или загрузки. Каждая запись в таблице релокаций обычно содержит следующие поля:
1. **Адрес**: Место в объектном файле, которое должно быть изменено (например, адрес вызова функции).
2. **Тип релокации**: Указывает, как нужно изменить адрес (например, относительный адрес, абсолютный адрес и т.д.).
3. **Символ**: Символ (например, имя функции или переменной), который нужно использовать для разрешения релокации.
4. **Добавочное значение**: Иногда релокации требуют добавления смещения к адресу.

### ==Пример использования таблицы релокаций==
Для демонстрации предположим, что вы скомпилировали два файла:
```asm
section .data
    message db "Hello, world!", 0

section .text
    extern printf
    global _start

_start:
    mov rdi, message    ; Адрес строки для printf
    call printf         ; Вызов внешней функции printf
    ret
```
После компиляции компилятор создаст объектный файл, который не будет знать точный адрес функции `printf`. Этот объектный файл будет содержать таблицу релокаций, в которой будет указано, что адрес вызова `printf` должен быть откорректирован, когда компоновщик свяжет этот файл с библиотекой, содержащей `printf`.

### ==Пример таблицы релокаций==
Используя утилиту **`readelf`** или **`objdump`**, можно увидеть таблицу релокаций в скомпилированном объектном файле. Например:
```bash
readelf -r main.o
```

Пример вывода таблицы релокаций:
```
Relocation section '.rela.text' at offset 0x3d0 contains 2 entries:
  Offset          Info           Type           Sym. Value    Sym. Name
 0000000000000005  000300000002   R_X86_64_PC32  0000000000000000 printf
 000000000000000a  000200000001   R_X86_64_32S   0000000000000000 message
```

#### Объяснение:
1. **Offset**: Адрес в секции `.text`, который нужно изменить.
2. **Info**: Информация о типе релокации и символе.
3. **Type**: Тип релокации (например, относительный или абсолютный адрес).
4. **Sym. Name**: Имя символа, для которого нужно изменить адрес (например, `printf`).

### ==Типы релокаций==
Существуют различные типы релокаций, которые зависят от архитектуры процессора и формата файла. В системах с архитектурой x86_64 встречаются такие типы релокаций, как:
- **R_X86_64_PC32**: Релокация для 32-битного относительного адреса, используемого для вызова или перехода.
- **R_X86_64_32**: Релокация для абсолютного 32-битного адреса.
- **R_X86_64_PLT32**: Релокация для вызова через таблицу процедурных ссылок (PLT) для динамических библиотек.

### ==Процесс релокации:==
1. **Во время компиляции**:
   - Когда компилятор не знает точный адрес символа (например, функции или переменной), он создаёт запись в таблице релокаций, чтобы указать компоновщику или загрузчику, что этот адрес нужно откорректировать позднее.

2. **Во время компоновки**:
   - Компоновщик просматривает таблицу релокаций и заменяет символы, такие как вызовы функций и ссылки на переменные, на их реальные адреса, которые определяются на этапе компоновки.

3. **Во время загрузки программы**:
   - Если программа использует динамические библиотеки, то некоторые релокации могут быть выполнены непосредственно загрузчиком, который подставляет адреса функций из библиотек, загруженных в память.
