В ассемблере директивы `macro` и `endmacro` используются для создания макросов — повторно используемых блоков кода. Макросы позволяют избежать дублирования кода и сделать его более читабельным, удобным и модульным. Макросы могут принимать параметры и генерировать различные участки кода в зависимости от того, какие значения им передаются.

### ==Основные директивы:==
1. **`macro`** — начало объявления макроса.
2. **`endmacro`** — конец объявления макроса.

### ==Основные возможности макросов:==
- Макросы могут принимать аргументы.
- Макросы позволяют генерировать код в зависимости от переданных аргументов.
- Они аналогичны функциям в других языках, но работают на уровне препроцессора, то есть до непосредственной компиляции кода.

### ==Синтаксис:==
```asm
%macro имя_макроса количество_аргументов
    ; тело макроса
%endmacro
```
- **имя_макроса** — это имя макроса, которое будет использоваться для его вызова.
- **количество_аргументов** — количество параметров, которые может принимать макрос. Можно указать диапазон, например, `2-3`, что означает, что макрос может принимать от двух до трёх аргументов.

### ==Пример макроса:==
```asm
%macro push_reg 1
    push %1       ; Макрос сохраняет переданный регистр в стек
%endmacro
```
В этом макросе `push_reg` принимает один аргумент, представляющий регистр, и генерирует команду `push` для этого регистра.

#### ==Пример использования:==
```asm
push_reg eax      ; Эквивалентно: push eax
push_reg ebx      ; Эквивалентно: push ebx
```

### ==Макросы с несколькими аргументами:==
Макросы могут принимать несколько аргументов, которые можно использовать внутри макроса.

#### Пример макроса с двумя аргументами:
```asm
%macro add_regs 2
    add %1, %2    ; Складываем два переданных регистра
%endmacro
```

#### Пример использования:
```asm
add_regs eax, ebx  ; Эквивалентно: add eax, ebx
```

### ==Удобство макросов:==
1. **Повторное использование кода**: Макросы позволяют сократить повторяющийся код. Вместо того чтобы каждый раз писать одно и то же, можно вызвать макрос.
2. **Аргументы**: С помощью аргументов можно создавать гибкие макросы, которые выполняют разные действия в зависимости от переданных значений.
3. **Читабельность**: Макросы делают код более читаемым, так как вместо длинных и сложных фрагментов можно использовать компактные вызовы макросов.

### ==Макрос с произвольным количеством аргументов:==
В некоторых случаях может потребоваться макрос, который принимает переменное количество аргументов. Это также возможно в NASM.

#### Пример макроса с переменным количеством аргументов:
```asm
%macro save_regs 2-*
    %rep %0            ; Повторяем для каждого аргумента
        push %1
        %rotate 1       ; Перемещаем следующий аргумент в начало
    %endrep
%endmacro
```
Здесь макрос `save_regs` может принимать от двух и более аргументов. Для каждого переданного аргумента будет выполнена инструкция `push`.

#### Пример использования:
```asm
save_regs eax, ebx, ecx   ; Эквивалентно: push eax, push ebx, push ecx
```

### ==Особенности работы макросов:==
- **Раскрытие макросов**: Когда вы вызываете макрос, его тело "раскрывается" (или подставляется) вместо вызова. Это значит, что макросы обрабатываются на этапе препроцессинга, и в итоговый код вставляется результат раскрытия макроса.
- **Ограничения**: Макросы не могут изменять состояние программы на уровне выполнения, так как это текстовая подстановка кода.

### Пример более сложного макроса:
```asm
%macro print_string 1
    mov rsi, %1           ; Адрес строки
    mov rdx, 13           ; Длина строки
    mov rax, 1            ; Системный вызов write
    mov rdi, 1            ; Пишем в stdout
    syscall
%endmacro
```
Этот макрос `print_string` выводит строку, адрес которой передаётся как аргумент.

#### Пример использования:
```asm
section .data
    msg db 'Hello, world!', 0

section .text
    global _start

_start:
    print_string msg    ; Вызов макроса для вывода строки
```

