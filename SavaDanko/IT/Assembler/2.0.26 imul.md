В архитектуре x86_64, команда `imul` используется для знакового умножения целых чисел. Она поддерживает различные формы и может работать с 8-, 16-, 32- и 64-битными операндами. В отличие от команды `mul`, которая используется для беззнакового умножения, `imul` выполняет умножение с учётом знака операндов.

### ==Основные формы команды `imul`==
1. **Однооперандная форма**:
   ```asm
   imul reg
   ```
   Умножает значение регистра `reg` на значение в регистре `rax` (для 64-битных значений) или `eax` (для 32-битных значений) с результатом в парах регистров:   
   - Для 64-битных значений: результат записывается в `rdx:rax`.
   - Для 32-битных значений: результат записывается в `edx:eax`.

   Пример:
   ```asm
   mov rax, 5
   mov rbx, -3
   imul rbx  ; rax = -15, rdx = 0
   ```

2. **Двухоперандная форма**:
   ```asm
   imul dest, src
   ```
   Умножает содержимое регистра `dest` на значение из `src`, результат сохраняется в `dest`. При этом используется только один регистр для хранения результата, и переполнение игнорируется.

   Пример:
   ```asm
   mov rax, 6
   imul rax, rbx  ; rax = rax * rbx
   ```

3. **Трёхоперандная форма**:
   ```asm
   imul dest, src, immediate
   ```
   Умножает значение из регистра `src` на заданное константное значение `immediate`, результат записывается в `dest`.

   Пример:
   ```asm
   imul rax, rbx, 5  ; rax = rbx * 5
   ```

### ==Описание работы==
- В однооперандной форме `imul` результат умножения записывается в два регистра: младший регистр (например, `rax` или `eax`) и старший регистр (например, `rdx` или `edx`). Старший регистр будет содержать знаковое расширение.
  
- В двух- и трёхоперандных формах результат записывается в регистр назначения, и переполнение не фиксируется (может быть потеряно).

### ==Флаги процессора==
- В однооперандной форме флаги `OF` (overflow) и `CF` (carry) устанавливаются, если старший регистр (например, `rdx` или `edx`) содержит ненулевые данные после умножения (что свидетельствует о переполнении).

- В двух- и трёхоперандных формах флаги не устанавливаются.

### ==Пример с использованием двухоперандной формы:==
```asm
section .data
    value1 dq 12
    value2 dq -3

section .text
    global _start
_start:
    mov rax, [value1]
    mov rbx, [value2]
    imul rax, rbx      ; rax = 12 * -3 = -36

    ; выход
    mov rax, 60        ; системный вызов "exit"
    xor rdi, rdi       ; код завершения 0
    syscall
```

### ==Основные преимущества `imul`:==
- Может работать как с 64-, так и с 32- и 16-битными значениями.
- Имеет несколько форм для более гибкого использования.
- Выполняет знаковое умножение, что полезно для работы с отрицательными числами.